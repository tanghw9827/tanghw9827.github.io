<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法与数据结构</title>
      <link href="/2024/08/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/08/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="图论">1 图论</h1><h2 id="图的定义">1.1 图的定义</h2><p><u>图（graph）</u>是一种非线性数据结构，由<u>顶点（vertex）</u>和<u>边（edge）</u>组成。我们可以将图 <span class="math inline">\(G\)</span> 抽象地表示为一组顶点 <span class="math inline">\(V\)</span> 和一组边 <span class="math inline">\(E\)</span> 的集合。以下示例展示了一个包含 5 个顶点和 7 条边的图。</p><p><span class="math display">\[\begin{aligned}V &amp; = \{ 1, 2, 3, 4, 5 \} \newlineE &amp; = \{ (1,2), (1,3), (1,5), (2,3), (2,4), (2,5), (4,5) \} \newlineG &amp; = \{ V, E \} \newline\end{aligned}\]</span></p><p>如果将顶点看作节点，将边看作连接各个节点的引用（指针），我们就可以将图看作一种从链表拓展而来的数据结构。如下图所示，<strong>相较于线性关系（链表）和分治关系（树），网络关系（图）的自由度更高</strong>，因而更为复杂。</p><figure><img src="https://github.com/krahets/hello-algo/raw/main/docs/chapter_graph/graph.assets/linkedlist_tree_graph.png" alt="链表、树、图之间的关系"><figcaption>链表、树、图之间的关系</figcaption></figure><h2 id="图的表示">1.2 图的表示</h2><p>图的常用表示方式包括“邻接矩阵”和“邻接表”。以下使用无向图进行举例。</p><h3 id="邻接矩阵">邻接矩阵</h3><p>设图的顶点数量为 <span class="math inline">\(n\)</span> ，<u>邻接矩阵（adjacency matrix）</u>使用一个 <span class="math inline">\(n \times n\)</span> 大小的矩阵来表示图，每一行（列）代表一个顶点，矩阵元素代表边，用 <span class="math inline">\(1\)</span> 或 <span class="math inline">\(0\)</span> 表示两个顶点之间是否存在边。</p><p>如下图所示，设邻接矩阵为 <span class="math inline">\(M\)</span>、顶点列表为 <span class="math inline">\(V\)</span> ，那么矩阵元素 <span class="math inline">\(M[i, j] = 1\)</span> 表示顶点 <span class="math inline">\(V[i]\)</span> 到顶点 <span class="math inline">\(V[j]\)</span> 之间存在边，反之 <span class="math inline">\(M[i, j] = 0\)</span> 表示两顶点之间无边。</p><figure><img src="https://github.com/krahets/hello-algo/raw/main/docs/chapter_graph/graph.assets/adjacency_matrix.png" alt="图的邻接矩阵表示"><figcaption>图的邻接矩阵表示</figcaption></figure><p>邻接矩阵具有以下特性。</p><ul><li>顶点不能与自身相连，因此邻接矩阵主对角线元素没有意义。</li><li>对于无向图，两个方向的边等价，此时邻接矩阵关于主对角线对称。</li><li>将邻接矩阵的元素从 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(0\)</span> 替换为权重，则可表示有权图。</li></ul><p>使用邻接矩阵表示图时，我们可以直接访问矩阵元素以获取边，因此增删查改操作的效率很高，时间复杂度均为 <span class="math inline">\(O(1)\)</span> 。然而，矩阵的空间复杂度为 <span class="math inline">\(O(n^2)\)</span> ，内存占用较多。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">createAdjMatrix</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">const</span> vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&amp; edges) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adjMatrix</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; edge : edges) &#123;<br>            adjMatrix[edge.first][edge.second] = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 如果是无向图，取消注释下一行</span><br>            <span class="hljs-comment">// adjMatrix[edge.second][edge.first] = 1;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> adjMatrix;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printAdjMatrix</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; adjMatrix)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; row : adjMatrix) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : row) &#123;<br>                cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>            cout &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Solution solution;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">edges</span>(m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        cin &gt;&gt; edges[i].first &gt;&gt; edges[i].second;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adjMatrix = solution.<span class="hljs-built_in">createAdjMatrix</span>(n, edges);<br>    solution.<span class="hljs-built_in">printAdjMatrix</span>(adjMatrix);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="邻接表">邻接表</h3><p><u>邻接表（adjacency list）</u>使用 <span class="math inline">\(n\)</span> 个链表来表示图，链表节点表示顶点。第 <span class="math inline">\(i\)</span> 个链表对应顶点 <span class="math inline">\(i\)</span> ，其中存储了该顶点的所有邻接顶点（与该顶点相连的顶点）。下图展示了一个使用邻接表存储的图的示例。</p><figure><img src="https://github.com/krahets/hello-algo/raw/main/docs/chapter_graph/graph.assets/adjacency_list.png" alt="图的邻接表表示"><figcaption>图的邻接表表示</figcaption></figure><p>邻接表仅存储实际存在的边，而边的总数通常远小于 <span class="math inline">\(n^2\)</span> ，因此它更加节省空间。然而，在邻接表中需要通过遍历链表来查找边，因此其时间效率不如邻接矩阵。</p><p>观察上图，<strong>邻接表结构与哈希表中的“链式地址”非常相似，因此我们也可以采用类似的方法来优化效率</strong>。比如当链表较长时，可以将链表转化为 AVL 树或红黑树，从而将时间效率从 <span class="math inline">\(O(n)\)</span> 优化至 <span class="math inline">\(O(\log n)\)</span> ；还可以把链表转换为哈希表，从而将时间复杂度降至 <span class="math inline">\(O(1)\)</span> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">createAdjList</span>(<span class="hljs-type">const</span> vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&amp; edges) &#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; adjList;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; edge : edges) &#123;<br>            adjList[edge.first].<span class="hljs-built_in">push_back</span>(edge.second);<br>            <span class="hljs-comment">// 如果是无向图，取消注释下一行</span><br>            <span class="hljs-comment">// adjList[edge.second].push_back(edge.first);</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> adjList;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printAdjList</span><span class="hljs-params">(<span class="hljs-type">const</span> unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; adjList)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; node : adjList) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Node &quot;</span> &lt;&lt; node.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : node.second) &#123;<br>                cout &lt;&lt; neighbor &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>            cout &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Solution solution;<br>    <span class="hljs-type">int</span> m;<br>    cin &gt;&gt; m;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">edges</span>(m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        cin &gt;&gt; edges[i].first &gt;&gt; edges[i].second;<br>    &#125;<br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; adjList = solution.<span class="hljs-built_in">createAdjList</span>(edges);<br>    solution.<span class="hljs-built_in">printAdjList</span>(adjList);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图的操作">1.3 图的操作</h2><ul><li>初始化</li><li>添加边，删除边</li><li>添加顶点，删除顶点 <figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-comment">/* 添加顶点 */</span><br><span class="hljs-type">void</span> addVertex(<span class="hljs-type">int</span> val) &#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 向顶点列表中添加新顶点的值</span><br>    vertices.push_back(val);<br>    <span class="hljs-comment">// 在邻接矩阵中添加一行</span><br>    adjMat.emplace_back(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>    <span class="hljs-comment">// 在邻接矩阵中添加一列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; &amp;<span class="hljs-built_in">row</span> : adjMat) &#123;<br>        <span class="hljs-built_in">row</span>.push_back(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 删除顶点 */</span><br><span class="hljs-type">void</span> removeVertex(<span class="hljs-type">int</span> index) &#123;<br>    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-built_in">size</span>()) &#123;<br>        throw out_of_range(<span class="hljs-string">&quot;顶点不存在&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 在顶点列表中移除索引 index 的顶点</span><br>    vertices.erase(vertices.begin() + index);<br>    <span class="hljs-comment">// 在邻接矩阵中删除索引 index 的行</span><br>    adjMat.erase(adjMat.begin() + index);<br>    <span class="hljs-comment">// 在邻接矩阵中删除索引 index 的列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; &amp;<span class="hljs-built_in">row</span> : adjMat) &#123;<br>        <span class="hljs-built_in">row</span>.erase(<span class="hljs-built_in">row</span>.begin() + index);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 添加边 */</span><br><span class="hljs-comment">// 参数 i, j 对应 vertices 元素索引</span><br><span class="hljs-type">void</span> addEdge(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123;<br>    <span class="hljs-comment">// 索引越界与相等处理</span><br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= <span class="hljs-built_in">size</span>() || j &gt;= <span class="hljs-built_in">size</span>() || i == j) &#123;<br>        throw out_of_range(<span class="hljs-string">&quot;顶点不存在&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 在无向图中，邻接矩阵关于主对角线对称，即满足 (i, j) == (j, i)</span><br>    adjMat[i][j] = <span class="hljs-number">1</span>;<br>    adjMat[j][i] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/* 删除边 */</span><br><span class="hljs-comment">// 参数 i, j 对应 vertices 元素索引</span><br><span class="hljs-type">void</span> removeEdge(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123;<br>    <span class="hljs-comment">// 索引越界与相等处理</span><br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= <span class="hljs-built_in">size</span>() || j &gt;= <span class="hljs-built_in">size</span>() || i == j) &#123;<br>        throw out_of_range(<span class="hljs-string">&quot;顶点不存在&quot;</span>);<br>    &#125;<br>    adjMat[i][j] = <span class="hljs-number">0</span>;<br>    adjMat[j][i] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="图的遍历">1.4 图的遍历</h2><h3 id="bfs广度优先搜索">BFS(广度优先搜索)</h3><p><strong>广度优先遍历是一种由近及远的遍历方式，从某个节点出发，始终优先访问距离最近的顶点，并一层层向外扩张</strong>。如下图所示，从左上角顶点出发，首先遍历该顶点的所有邻接顶点，然后遍历下一个顶点的所有邻接顶点，以此类推，直至所有顶点访问完毕。</p><figure><img src="https://github.com/krahets/hello-algo/raw/main/docs//chapter_graph/graph_traversal.assets/graph_bfs.png" alt="图的广度优先遍历"><figcaption>图的广度优先遍历</figcaption></figure><h3 id="dfs深度优先搜索">DFS(深度优先搜索)</h3><p><strong>深度优先遍历是一种优先走到底、无路可走再回头的遍历方式</strong>。如下图所示，从左上角顶点出发，访问当前顶点的某个邻接顶点，直到走到尽头时返回，再继续走到尽头并返回，以此类推，直至所有顶点遍历完成。</p><figure><img src="https://github.com/krahets/hello-algo/raw/main/docs//chapter_graph/graph_traversal.assets/graph_dfs.png" alt="图的深度优先遍历"><figcaption>图的深度优先遍历</figcaption></figure><h2 id="图的遍历基本题型">1.5 图的遍历基本题型</h2><ul><li>有向图的完全可达性</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(visited[x])&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    visited[x] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (graph.<span class="hljs-built_in">find</span>(x) != graph.<span class="hljs-built_in">end</span>())&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i : graph.<span class="hljs-built_in">at</span>(x))&#123;<br>            <span class="hljs-built_in">dfs</span>(graph, i, visited);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; graph;<br>    <span class="hljs-type">int</span> s, t;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        graph[s].<span class="hljs-built_in">push_back</span>(t);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n<span class="hljs-number">+1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">1</span>, visited);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!visited[i])&#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>所有可达路径 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; n, <span class="hljs-type">int</span> x, vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; result)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x == n) &#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (graph.<span class="hljs-built_in">find</span>(x) != graph.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i : graph.<span class="hljs-built_in">at</span>(x) &#123;  <span class="hljs-comment">//使用[x]的话当键不存在，将抛出异常而而插入默认值修改graph</span><br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">dfs</span>(graph, n, i, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-built_in">main</span>() &#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; graph;<br>    <span class="hljs-type">int</span> s, t;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        graph[s].<span class="hljs-built_in">push_back</span>(t);<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dfs</span>(graph, n, <span class="hljs-number">1</span>, path, result);<br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; path : result) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>                cout &lt;&lt; path[i] &lt;&lt; endl;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cout &lt;&lt; path[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li>岛屿数量（DFS） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (visited[i][j] || graph[i][j] == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    visited[i][j] = <span class="hljs-literal">true</span>; <br>    <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) <span class="hljs-built_in">dfs</span>(graph, visited, i - <span class="hljs-number">1</span>, j);<br>    <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; graph[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">dfs</span>(graph, visited, i, j + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; graph.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">dfs</span>(graph, visited, i + <span class="hljs-number">1</span>, j);<br>    <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) <span class="hljs-built_in">dfs</span>(graph, visited, i, j - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            cin &gt;&gt; graph[i][j]; <br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; graph[i][j] == <span class="hljs-number">1</span>) &#123;<br>                result++;<br>                <span class="hljs-built_in">dfs</span>(graph, visited, i, j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; result &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>岛屿数量（BFS） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que;<br>    que.<span class="hljs-built_in">push</span>(&#123;i, j&#125;);<br>    visited[i][j] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> [x, y] = que.<span class="hljs-built_in">front</span>();<br>        que.<span class="hljs-built_in">pop</span>(); <br>        <span class="hljs-keyword">if</span>(x<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; !visited[x<span class="hljs-number">-1</span>][y] &amp;&amp; graph[x<span class="hljs-number">-1</span>][y] == <span class="hljs-number">1</span>)&#123;<br>            visited[x<span class="hljs-number">-1</span>][y] = <span class="hljs-literal">true</span>;<br>            que.<span class="hljs-built_in">push</span>(&#123;x<span class="hljs-number">-1</span>, y&#125;);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(y<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; !visited[x][y<span class="hljs-number">-1</span>] &amp;&amp; graph[x][y<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span>)&#123;<br>            visited[x][y<span class="hljs-number">-1</span>] = <span class="hljs-literal">true</span>;<br>            que.<span class="hljs-built_in">push</span>(&#123;x, y<span class="hljs-number">-1</span>&#125;);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(x<span class="hljs-number">+1</span> &lt; graph.<span class="hljs-built_in">size</span>() &amp;&amp; !visited[x<span class="hljs-number">+1</span>][y] &amp;&amp; graph[x<span class="hljs-number">+1</span>][y] == <span class="hljs-number">1</span>)&#123;<br>            visited[x<span class="hljs-number">+1</span>][y] = <span class="hljs-literal">true</span>;<br>            que.<span class="hljs-built_in">push</span>(&#123;x<span class="hljs-number">+1</span>, y&#125;);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(y<span class="hljs-number">+1</span> &lt; graph[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; !visited[x][y<span class="hljs-number">+1</span>] &amp;&amp; graph[x][y<span class="hljs-number">+1</span>] == <span class="hljs-number">1</span>)&#123;<br>            visited[x][y<span class="hljs-number">+1</span>] = <span class="hljs-literal">true</span>;<br>            que.<span class="hljs-built_in">push</span>(&#123;x, y<span class="hljs-number">+1</span>&#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            cin &gt;&gt; graph[i][j];<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; graph[i][j] == <span class="hljs-number">1</span>) &#123;<br>                result++;<br>                <span class="hljs-built_in">bfs</span>(graph, visited, i, j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; result &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>沉没孤岛（DFS） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> mark)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (visited[i][j] || graph[i][j] == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    visited[i][j] = mark; <br>    <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) <span class="hljs-built_in">dfs</span>(graph, visited, i - <span class="hljs-number">1</span>, j, mark);<br>    <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; graph[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">dfs</span>(graph, visited, i, j + <span class="hljs-number">1</span>, mark);<br>    <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; graph.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">dfs</span>(graph, visited, i + <span class="hljs-number">1</span>, j, mark);<br>    <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) <span class="hljs-built_in">dfs</span>(graph, visited, i, j - <span class="hljs-number">1</span>, mark);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            cin &gt;&gt; graph[i][j]; <br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[i][<span class="hljs-number">0</span>] &amp;&amp; graph[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(graph, visited, i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!visited[i][m<span class="hljs-number">-1</span>] &amp;&amp; graph[i][m<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(graph, visited, i, m<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[<span class="hljs-number">0</span>][j] &amp;&amp; graph[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(graph, visited, <span class="hljs-number">0</span>, j, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!visited[n<span class="hljs-number">-1</span>][j] &amp;&amp; graph[n<span class="hljs-number">-1</span>][j] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(graph, visited, n<span class="hljs-number">-1</span>, j, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; graph[i][j] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">dfs</span>(graph, visited, i, j, <span class="hljs-number">2</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (visited[i][j] == <span class="hljs-number">2</span>) &#123;<br>                graph[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            cout &lt;&lt; graph[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>其余岛屿问题（岛屿的最大面积、孤岛的总面积、建造最大工岛、字符串接龙、岛屿的周长）</p></li></ul><h2 id="并查集">1.6 并查集</h2><p>并查集常用来解决连通性问题，当我们需要判断两个元素是否在同一个集合里的时候，可以使用并查集。 并查集主要有两个功能：</p><ul><li>将两个元素添加到一个集合中。</li><li>判断两个元素在不在同一个集合 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (n, <span class="hljs-number">0</span>); <span class="hljs-comment">// C++里的一种数组结构</span><br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 路径压缩</span><br>&#125;<br><br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="并查集基本题型">1.7 并查集基本题型</h2><ul><li>寻找可能的路径 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n; <span class="hljs-comment">// 节点数量</span><br>vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (<span class="hljs-number">101</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 按照节点大小定义数组大小</span><br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)  father[i] = i;<br>&#125;<br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>&#125;<br><br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> m, s, t, source, destination;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-built_in">join</span>(s, t);<br>    &#125;<br>    cin &gt;&gt; source &gt;&gt; destination;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSame</span>(source, destination)) cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>冗余连接 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n; <span class="hljs-comment">// 节点数量</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">father</span><span class="hljs-params">(<span class="hljs-number">1001</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 按照节点大小范围定义数组</span><br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>&#125;<br><br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> s, t;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">init</span>();<br><br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; edges;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        edges.<span class="hljs-built_in">push_back</span>(&#123;s, t&#125;);<br>    &#125;<br><br>    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; last_edge;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; edge : edges) &#123;<br>        s = edge.first;<br>        t = edge.second;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSame</span>(s, t)) &#123;<br>            last_edge = edge;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">join</span>(s, t);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 输出最后导致环的那条边</span><br>    cout &lt;&lt; last_edge.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; last_edge.second &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>其余并查集问题（冗余连接II）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>决策模块概述</title>
      <link href="/2024/08/03/%E5%86%B3%E7%AD%96%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/08/03/%E5%86%B3%E7%AD%96%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="输入输出">1 输入输出</h1><p>控制模块的目标是基于规划好的轨迹和当前车辆状态，输出控制指令给车辆，为自动驾驶车辆提供舒适的驾驶体验。</p><figure><img src="/images/resized_control_module.png" alt="Fig 1 控制模块"><figcaption>Fig 1 控制模块</figcaption></figure><ul><li>输入：规划好的轨迹（planning）和当前车辆状态(localization &amp;&amp; chassis)</li><li>输出：油门、刹车及方向盘转角(canbus)</li></ul><h1 id="车辆模型">2 车辆模型</h1><h2 id="自行车运动学模型">2.1 自行车运动学模型</h2><p>在自行车模型中，左右两个前轮由点 A 点的一个单轮表示。类似地，后轮由点 B 点的一个后轮表示。运动学模型中的主要假设是点 A 和 B 点的速度方向分别位于前轮和后轮的方向上。</p><p>假设：</p><ul><li>车辆的运动被限制在XY平面内，即没有考虑“上升”和“下降”运动。</li><li>左右轮转向运动相同，左右轮合成一个轮子。</li><li>忽略车轮的侧偏角，A点和B点的速度方向分别位于前轮和后轮的方向上。</li><li>忽略负载转移带来的质心位置变化。</li><li>车辆是刚性车身。</li></ul><figure><img src="/images/resized_Bicycle_KInematics.png" alt="Fig 2 自行车运动学模型"><figcaption>Fig 2 自行车运动学模型</figcaption></figure><h3 id="符号定义">符号定义</h3><ul><li><span class="math inline">\(C\)</span>：车辆质心</li><li><span class="math inline">\(\gamma = \psi + \beta\)</span>：航向角（质心速度方向与大地坐标系<span class="math inline">\(\vec{X}\)</span>轴的夹角）</li><li><span class="math inline">\(\beta\)</span>：侧偏角（质心速度方向和车身纵轴的夹角）</li><li><span class="math inline">\(\psi\)</span>：横摆角（车身轴线与大地坐标系<span class="math inline">\(\vec{X}\)</span>轴的夹角）</li><li><span class="math inline">\(\dot{\psi} = \frac{V}{R}\)</span>：低速情况下，假设<span class="math inline">\(R\)</span>变化缓慢</li></ul><p>这里假设相互作用的前后轮的侧偏角 <span class="math inline">\(\beta_f\)</span> 和 <span class="math inline">\(\beta_r\)</span> 都为0，对于车辆的低速运动（例如，速度小于5 m/s），这是一个合理的假设。在低速行驶时，轮胎产生的侧向力很小，两个轮胎的总侧向力是 <span class="math inline">\(\frac{mV^2}{R}\)</span>，此时前后轮的侧偏角可以近似为0（侧向力的大小与侧偏角近似成比例关系）。</p><h3 id="运动学方程">运动学方程</h3><p>AB点运动学模型的方程，可以得出：</p><p><span class="math display">\[\dot{X} = V \cos(\psi + \beta)\]</span></p><p><span class="math display">\[\dot{Y} = V \sin(\psi + \beta)\]</span></p><p><span class="math display">\[\dot{\psi} = \frac{V \cos(\beta)}{l_r + l_f} (\tan(\delta_f) - \tan(\delta_r))\]</span></p><h3 id="阿克曼转向车辆模型">阿克曼转向车辆模型</h3><p>实际应用时，一般会使用后轴中心的运动学模型（B点），即阿克曼转向车辆模型。</p><figure><img src="/images/resized_Ackerman_steering_model.png" alt="Fig 3 阿克曼转向车辆模型"><figcaption>Fig 3 阿克曼转向车辆模型</figcaption></figure><p>假定 <span class="math inline">\(\beta = 0\)</span>， <span class="math inline">\(\delta_r = 0\)</span>，<span class="math inline">\(\delta\)</span>为前轮转角，得：</p><p><span class="math display">\[\dot{X} = V \cos(\psi)\]</span></p><p><span class="math display">\[\dot{Y} = V \sin(\psi)\]</span></p><p><span class="math display">\[\dot{\psi} = \frac{V}{l_r} \tan(\delta_f)\]</span></p><h2 id="车辆二自由度动力学模型">2.2 车辆二自由度动力学模型</h2><p>在更高的车速下，不能再假设每个车轮的速度方向都在车轮的方向上，而是需要考虑轮胎的侧向力。轮胎的侧偏角定义为轮胎方向与车轮速度矢量方向之间的夹角。</p><figure><img src="/images/resized_slip_angle.png" alt="Fig 4 侧偏角"><figcaption>Fig 4 侧偏角</figcaption></figure><p>假设：</p><ul><li>车辆的运动被限制在XY平面内，即没有考虑“上升”和“下降”运动。</li><li>车轮的转向运动相同，车轮合成一个轮子。</li><li>车辆是刚性车身。</li><li>忽略负载转移带来的质心位置变化。</li><li>汽车纵向速度不变，即：<span class="math inline">\(V_y = C\)</span>。</li><li>忽略转向系统的影响，直接以前轮转角作为输入。</li><li>汽车横向加速度满足：<span class="math inline">\(a_y \leq 0.4g\)</span>，实验结果表明，对于小的侧偏角。此时轮胎侧偏力与侧偏角近似成正比。</li></ul><p>在上述假设下，汽车被简化为只有侧向和横摆两个自由度的两轮汽车模型。</p><figure><img src="/images/resized_Dynamic_Bicycle_Model.png" alt="Fig 5 车辆二自由度动力学模型"><figcaption>Fig 5 车辆二自由度动力学模型</figcaption></figure><p>由于质心侧偏角远小于车辆航向角和横摆角，在实际应用中可以认为航向角与横摆角相等,受力分析可以得到： <span class="math display">\[(F_{yf} \cos(\delta) - F_{xf} \sin(\delta)) + F_{yr} = m(\dot{v_y} + v_x \dot{\psi})\]</span></p><p><span class="math display">\[l_f (F_{yf} \cos(\delta) - F_{xf} \sin(\delta)) - l_r F_{yr} = I_z \ddot{\psi}\]</span> 这里横向加速度带有<span class="math inline">\(v_x\)</span>项，因为是矢量求导。</p><p>车辆的横向侧偏力可以写为</p><p><span class="math display">\[F_{yf} = 2 * c_f (\delta - \theta_{f}) \]</span></p><p><span class="math display">\[F_{yr} = 2 * c_r (-\theta_{r})\]</span></p><p><span class="math inline">\(c_f, c_r\)</span> 定义为侧偏刚度, 2 表示有两个轮子。</p><p>使用小角度假设， <span class="math display">\[\tan(\theta_{f}) = \frac{V_{yf} + l_{f}\dot{\psi}}{V_{x}}, \quad \tan(\theta_{r}) = \frac{V_{yr} - l_{r}\dot{\psi}}{V_{x}}\]</span></p><p><span class="math display">\[\theta_{f} = \frac{V_{yf} + l_{f}\dot{\psi}}{V_{x}}, \quad \theta_{r} = \frac{V_{yr} - l_{r}\dot{\psi}}{V_{x}}\]</span></p><p><span class="math display">\[\cos(\delta) \approx 1, \quad \sin(\delta) \approx 0\]</span></p><p>可以得到，</p><p><span class="math display">\[\begin{bmatrix}\dot{v}_y \\\ddot{\psi}\end{bmatrix}=\begin{bmatrix}-\frac{2c_f + 2c_r}{mv_x} &amp; \frac{2l_r c_r - 2l_f c_f}{mv_x} - v_x \\\frac{2l_r c_r - 2l_f c_f}{I_z v_x} &amp; -\frac{2l_f^2 c_f + 2l_r^2 c_r}{I_z v_x}\end{bmatrix}\begin{bmatrix}v_y \\\dot{\psi}\end{bmatrix}+\begin{bmatrix}\frac{2c_f}{m} \\\frac{2l_f c_f}{I_z}\end{bmatrix}\delta\]</span></p><p>定义误差：</p><p><span class="math display">\[\dot{\psi} = \frac{V_{x}}{R}\]</span></p><p><span class="math display">\[\ddot{e_{1}} = \ddot{y} + V_{x}\dot{\psi} - \frac{V_{x}^2}{R}\]</span></p><p><span class="math display">\[e_{2} = \psi - \psi_{des}\]</span></p><p>其中，<span class="math inline">\(e_1\)</span>为横向位置误差，<span class="math inline">\(e_2\)</span>为航向角误差。</p><p><span class="math display">\[\dot{x} = Ax + Bu + C\psi_{des}\]</span></p><p><span class="math display">\[X = \begin{bmatrix} e_1 &amp; e_2 &amp; \dot{e}_1 &amp; \dot{e}_2 \end{bmatrix}^T, \quad u = \delta\]</span></p><p><span class="math display">\[A = \begin{bmatrix}0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; -\frac{2c_f+2c_r}{mV_x} &amp; \frac{2c_f+2c_r}{m} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{mV_x} \\0 &amp; 0 &amp; 0 &amp; 1 \\0 &amp; \frac{2c_f\ell_f - 2c_r\ell_r}{I_zV_x} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{I_z} &amp; -\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix}\]</span></p><p><span class="math display">\[B = \begin{bmatrix}0 \\\frac{2c_f}{m} \\0 \\\frac{2c_f\ell_f}{I_z}\end{bmatrix} \delta, \quadC = \begin{bmatrix}0 \\\frac{-2c_f\ell_f + 2c_r\ell_r - V_x}{mV_x} \\0 \\-\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix}\]</span></p><p>综上，车辆二自由度动力学模型可以写为：</p><p><span class="math display">\[\frac{d}{dt} \begin{bmatrix}e_1 \\\dot{e}_1 \\e_2 \\\dot{e}_2\end{bmatrix} = \begin{bmatrix}0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; -\frac{2c_f+2c_r}{mV_x} &amp; \frac{2c_f+2c_r}{m} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{mV_x} \\0 &amp; 0 &amp; 0 &amp; 1 \\0 &amp; \frac{2c_f\ell_f - 2c_r\ell_r}{I_zV_x} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{I_z} &amp; -\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix}\begin{bmatrix}e_1 \\\dot{e}_1 \\e_2 \\\dot{e}_2\end{bmatrix}+\begin{bmatrix}0 \\\frac{2c_f}{m} \\0 \\\frac{2c_f\ell_f}{I_z}\end{bmatrix} \delta+\begin{bmatrix}0 \\\frac{-2c_f\ell_f + 2c_r\ell_r - V_x}{mV_x} \\0 \\-\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix} \dot{\psi}_{des}\]</span></p><h2 id="运动学和动力学参数标定">2.2 运动学和动力学参数标定</h2>]]></content>
      
      
      <categories>
          
          <category> 决策算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>规划算法串讲</title>
      <link href="/2024/08/02/%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E4%B8%B2%E8%AE%B2/"/>
      <url>/2024/08/02/%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E4%B8%B2%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="输入输出">1 输入输出</h1><p>控制模块的目标是基于规划好的轨迹和当前车辆状态，输出控制指令给车辆，为自动驾驶车辆提供舒适的驾驶体验。</p><figure><img src="/images/resized_control_module.png" alt="Fig 1 控制模块"><figcaption>Fig 1 控制模块</figcaption></figure><ul><li>输入：规划好的轨迹（planning）和当前车辆状态(localization &amp;&amp; chassis)</li><li>输出：油门、刹车及方向盘转角(canbus)</li></ul><h1 id="车辆模型">2 车辆模型</h1><h2 id="自行车运动学模型">2.1 自行车运动学模型</h2><p>在自行车模型中，左右两个前轮由点 A 点的一个单轮表示。类似地，后轮由点 B 点的一个后轮表示。运动学模型中的主要假设是点 A 和 B 点的速度方向分别位于前轮和后轮的方向上。</p><p>假设：</p><ul><li>车辆的运动被限制在XY平面内，即没有考虑“上升”和“下降”运动。</li><li>左右轮转向运动相同，左右轮合成一个轮子。</li><li>忽略车轮的侧偏角，A点和B点的速度方向分别位于前轮和后轮的方向上。</li><li>忽略负载转移带来的质心位置变化。</li><li>车辆是刚性车身。</li></ul><figure><img src="/images/resized_Bicycle_KInematics.png" alt="Fig 2 自行车运动学模型"><figcaption>Fig 2 自行车运动学模型</figcaption></figure><h3 id="符号定义">符号定义</h3><ul><li><span class="math inline">\(C\)</span>：车辆质心</li><li><span class="math inline">\(\gamma = \psi + \beta\)</span>：航向角（质心速度方向与大地坐标系<span class="math inline">\(\vec{X}\)</span>轴的夹角）</li><li><span class="math inline">\(\beta\)</span>：侧偏角（质心速度方向和车身纵轴的夹角）</li><li><span class="math inline">\(\psi\)</span>：横摆角（车身轴线与大地坐标系<span class="math inline">\(\vec{X}\)</span>轴的夹角）</li><li><span class="math inline">\(\dot{\psi} = \frac{V}{R}\)</span>：低速情况下，假设<span class="math inline">\(R\)</span>变化缓慢</li></ul><p>这里假设相互作用的前后轮的侧偏角 <span class="math inline">\(\beta_f\)</span> 和 <span class="math inline">\(\beta_r\)</span> 都为0，对于车辆的低速运动（例如，速度小于5 m/s），这是一个合理的假设。在低速行驶时，轮胎产生的侧向力很小，两个轮胎的总侧向力是 <span class="math inline">\(\frac{mV^2}{R}\)</span>，此时前后轮的侧偏角可以近似为0（侧向力的大小与侧偏角近似成比例关系）。</p><h3 id="运动学方程">运动学方程</h3><p>AB点运动学模型的方程，可以得出：</p><p><span class="math display">\[\dot{X} = V \cos(\psi + \beta)\]</span></p><p><span class="math display">\[\dot{Y} = V \sin(\psi + \beta)\]</span></p><p><span class="math display">\[\dot{\psi} = \frac{V \cos(\beta)}{l_r + l_f} (\tan(\delta_f) - \tan(\delta_r))\]</span></p><h3 id="阿克曼转向车辆模型">阿克曼转向车辆模型</h3><p>实际应用时，一般会使用后轴中心的运动学模型（B点），即阿克曼转向车辆模型。</p><figure><img src="/images/resized_Ackerman_steering_model.png" alt="Fig 3 阿克曼转向车辆模型"><figcaption>Fig 3 阿克曼转向车辆模型</figcaption></figure><p>假定 <span class="math inline">\(\beta = 0\)</span>， <span class="math inline">\(\delta_r = 0\)</span>，<span class="math inline">\(\delta\)</span>为前轮转角，得：</p><p><span class="math display">\[\dot{X} = V \cos(\psi)\]</span></p><p><span class="math display">\[\dot{Y} = V \sin(\psi)\]</span></p><p><span class="math display">\[\dot{\psi} = \frac{V}{l_r} \tan(\delta_f)\]</span></p><h2 id="车辆二自由度动力学模型">2.2 车辆二自由度动力学模型</h2><p>在更高的车速下，不能再假设每个车轮的速度方向都在车轮的方向上，而是需要考虑轮胎的侧向力。轮胎的侧偏角定义为轮胎方向与车轮速度矢量方向之间的夹角。</p><figure><img src="/images/resized_slip_angle.png" alt="Fig 4 侧偏角"><figcaption>Fig 4 侧偏角</figcaption></figure><p>假设：</p><ul><li>车辆的运动被限制在XY平面内，即没有考虑“上升”和“下降”运动。</li><li>车轮的转向运动相同，车轮合成一个轮子。</li><li>车辆是刚性车身。</li><li>忽略负载转移带来的质心位置变化。</li><li>汽车纵向速度不变，即：<span class="math inline">\(V_y = C\)</span>。</li><li>忽略转向系统的影响，直接以前轮转角作为输入。</li><li>汽车横向加速度满足：<span class="math inline">\(a_y \leq 0.4g\)</span>，实验结果表明，对于小的侧偏角。此时轮胎侧偏力与侧偏角近似成正比。</li></ul><p>在上述假设下，汽车被简化为只有侧向和横摆两个自由度的两轮汽车模型。</p><figure><img src="/images/resized_Dynamic_Bicycle_Model.png" alt="Fig 5 车辆二自由度动力学模型"><figcaption>Fig 5 车辆二自由度动力学模型</figcaption></figure><p>由于质心侧偏角远小于车辆航向角和横摆角，在实际应用中可以认为航向角与横摆角相等,受力分析可以得到： <span class="math display">\[(F_{yf} \cos(\delta) - F_{xf} \sin(\delta)) + F_{yr} = m(\dot{v_y} + v_x \dot{\psi})\]</span></p><p><span class="math display">\[l_f (F_{yf} \cos(\delta) - F_{xf} \sin(\delta)) - l_r F_{yr} = I_z \ddot{\psi}\]</span> 这里横向加速度带有<span class="math inline">\(v_x\)</span>项，因为是矢量求导。</p><p>车辆的横向侧偏力可以写为</p><p><span class="math display">\[F_{yf} = 2 * c_f (\delta - \theta_{f}) \]</span></p><p><span class="math display">\[F_{yr} = 2 * c_r (-\theta_{r})\]</span></p><p><span class="math inline">\(c_f, c_r\)</span> 定义为侧偏刚度, 2 表示有两个轮子。</p><p>使用小角度假设， <span class="math display">\[\tan(\theta_{f}) = \frac{V_{yf} + l_{f}\dot{\psi}}{V_{x}}, \quad \tan(\theta_{r}) = \frac{V_{yr} - l_{r}\dot{\psi}}{V_{x}}\]</span></p><p><span class="math display">\[\theta_{f} = \frac{V_{yf} + l_{f}\dot{\psi}}{V_{x}}, \quad \theta_{r} = \frac{V_{yr} - l_{r}\dot{\psi}}{V_{x}}\]</span></p><p><span class="math display">\[\cos(\delta) \approx 1, \quad \sin(\delta) \approx 0\]</span></p><p>可以得到，</p><p><span class="math display">\[\begin{bmatrix}\dot{v}_y \\\ddot{\psi}\end{bmatrix}=\begin{bmatrix}-\frac{2c_f + 2c_r}{mv_x} &amp; \frac{2l_r c_r - 2l_f c_f}{mv_x} - v_x \\\frac{2l_r c_r - 2l_f c_f}{I_z v_x} &amp; -\frac{2l_f^2 c_f + 2l_r^2 c_r}{I_z v_x}\end{bmatrix}\begin{bmatrix}v_y \\\dot{\psi}\end{bmatrix}+\begin{bmatrix}\frac{2c_f}{m} \\\frac{2l_f c_f}{I_z}\end{bmatrix}\delta\]</span></p><p>定义误差：</p><p><span class="math display">\[\dot{\psi} = \frac{V_{x}}{R}\]</span></p><p><span class="math display">\[\ddot{e_{1}} = \ddot{y} + V_{x}\dot{\psi} - \frac{V_{x}^2}{R}\]</span></p><p><span class="math display">\[e_{2} = \psi - \psi_{des}\]</span></p><p>其中，<span class="math inline">\(e_1\)</span>为横向位置误差，<span class="math inline">\(e_2\)</span>为航向角误差。</p><p><span class="math display">\[\dot{x} = Ax + Bu + C\psi_{des}\]</span></p><p><span class="math display">\[X = \begin{bmatrix} e_1 &amp; e_2 &amp; \dot{e}_1 &amp; \dot{e}_2 \end{bmatrix}^T, \quad u = \delta\]</span></p><p><span class="math display">\[A = \begin{bmatrix}0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; -\frac{2c_f+2c_r}{mV_x} &amp; \frac{2c_f+2c_r}{m} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{mV_x} \\0 &amp; 0 &amp; 0 &amp; 1 \\0 &amp; \frac{2c_f\ell_f - 2c_r\ell_r}{I_zV_x} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{I_z} &amp; -\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix}\]</span></p><p><span class="math display">\[B = \begin{bmatrix}0 \\\frac{2c_f}{m} \\0 \\\frac{2c_f\ell_f}{I_z}\end{bmatrix} \delta, \quadC = \begin{bmatrix}0 \\\frac{-2c_f\ell_f + 2c_r\ell_r - V_x}{mV_x} \\0 \\-\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix}\]</span></p><p>综上，车辆二自由度动力学模型可以写为：</p><p><span class="math display">\[\frac{d}{dt} \begin{bmatrix}e_1 \\\dot{e}_1 \\e_2 \\\dot{e}_2\end{bmatrix} = \begin{bmatrix}0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; -\frac{2c_f+2c_r}{mV_x} &amp; \frac{2c_f+2c_r}{m} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{mV_x} \\0 &amp; 0 &amp; 0 &amp; 1 \\0 &amp; \frac{2c_f\ell_f - 2c_r\ell_r}{I_zV_x} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{I_z} &amp; -\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix}\begin{bmatrix}e_1 \\\dot{e}_1 \\e_2 \\\dot{e}_2\end{bmatrix}+\begin{bmatrix}0 \\\frac{2c_f}{m} \\0 \\\frac{2c_f\ell_f}{I_z}\end{bmatrix} \delta+\begin{bmatrix}0 \\\frac{-2c_f\ell_f + 2c_r\ell_r - V_x}{mV_x} \\0 \\-\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix} \dot{\psi}_{des}\]</span></p><h2 id="运动学和动力学参数标定">2.2 运动学和动力学参数标定</h2>]]></content>
      
      
      <categories>
          
          <category> 规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>控制基本原理</title>
      <link href="/2024/08/01/%E6%8E%A7%E5%88%B6%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2024/08/01/%E6%8E%A7%E5%88%B6%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="输入输出">1 输入输出</h1><p>控制模块的目标是基于规划好的轨迹和当前车辆状态，输出控制指令给车辆，为自动驾驶车辆提供舒适的驾驶体验。</p><p><img src="/images/resized_control_module.png" alt="Fig 1 控制模块" style="width:60%;height:auto;"></p><ul><li>输入：规划好的轨迹（planning）和当前车辆状态(localization &amp;&amp; chassis)</li><li>输出：油门、刹车及方向盘转角(canbus)</li></ul><h1 id="车辆模型">2 车辆模型</h1><h2 id="自行车运动学模型">2.1 自行车运动学模型</h2><p>在自行车模型中，左右两个前轮由点 A 点的一个单轮表示。类似地，后轮由点 B 点的一个后轮表示。运动学模型中的主要假设是点 A 和 B 点的速度方向分别位于前轮和后轮的方向上。</p><p>假设：</p><ul><li>车辆的运动被限制在XY平面内，即没有考虑“上升”和“下降”运动。</li><li>左右轮转向运动相同，左右轮合成一个轮子。</li><li>忽略车轮的侧偏角，A点和B点的速度方向分别位于前轮和后轮的方向上。</li><li>忽略负载转移带来的质心位置变化。</li><li>车辆是刚性车身。</li></ul><p><img src="/images/resized_Bicycle_KInematics.png" alt="Fig 2 自行车运动学模型" style="width:60%;height:auto;"></p><h3 id="符号定义">符号定义</h3><ul><li><span class="math inline">\(C\)</span>：车辆质心</li><li><span class="math inline">\(\gamma = \psi + \beta\)</span>：航向角（质心速度方向与大地坐标系<span class="math inline">\(\vec{X}\)</span>轴的夹角）</li><li><span class="math inline">\(\beta\)</span>：侧偏角（质心速度方向和车身纵轴的夹角）</li><li><span class="math inline">\(\psi\)</span>：横摆角（车身轴线与大地坐标系<span class="math inline">\(\vec{X}\)</span>轴的夹角）</li><li><span class="math inline">\(\dot{\psi} = \frac{V}{R}\)</span>：低速情况下，假设<span class="math inline">\(R\)</span>变化缓慢</li></ul><p>这里假设相互作用的前后轮的侧偏角 <span class="math inline">\(\beta_f\)</span> 和 <span class="math inline">\(\beta_r\)</span> 都为0，对于车辆的低速运动（例如，速度小于5 m/s），这是一个合理的假设。在低速行驶时，轮胎产生的侧向力很小，两个轮胎的总侧向力是 <span class="math inline">\(\frac{mV^2}{R}\)</span>，此时前后轮的侧偏角可以近似为0（侧向力的大小与侧偏角近似成比例关系）。</p><h3 id="运动学方程">运动学方程</h3><p>AB点运动学模型的方程，可以得出：</p><p><span class="math display">\[\dot{X} = V \cos(\psi + \beta)\]</span></p><p><span class="math display">\[\dot{Y} = V \sin(\psi + \beta)\]</span></p><p><span class="math display">\[\dot{\psi} = \frac{V \cos(\beta)}{l_r + l_f} (\tan(\delta_f) - \tan(\delta_r))\]</span></p><h3 id="阿克曼转向车辆模型">阿克曼转向车辆模型</h3><p>实际应用时，一般会使用后轴中心的运动学模型（B点），即阿克曼转向车辆模型。</p><p><img src="/images/resized_Ackerman_steering_model.png" alt="Fig 3 阿克曼转向车辆模型" style="width:60%;height:auto;"></p><p>假定 <span class="math inline">\(\beta = 0\)</span>， <span class="math inline">\(\delta_r = 0\)</span>，<span class="math inline">\(\delta\)</span>为前轮转角，得：</p><p><span class="math display">\[\dot{X} = V \cos(\psi)\]</span></p><p><span class="math display">\[\dot{Y} = V \sin(\psi)\]</span></p><p><span class="math display">\[\dot{\psi} = \frac{V}{L} \tan(\delta_f)\]</span></p><h2 id="车辆二自由度动力学模型">2.2 车辆二自由度动力学模型</h2><p>在更高的车速下，不能再假设每个车轮的速度方向都在车轮的方向上，而是需要考虑轮胎的侧向力。轮胎的侧偏角定义为轮胎方向与车轮速度矢量方向之间的夹角。</p><p><img src="/images/resized_slip_angle.png" alt="Fig 4 侧偏角" style="width:60%;height:auto;"></p><p>假设：</p><ul><li>车辆的运动被限制在XY平面内，即没有考虑“上升”和“下降”运动。</li><li>车轮的转向运动相同，车轮合成一个轮子。</li><li>车辆是刚性车身。</li><li>忽略负载转移带来的质心位置变化。</li><li>汽车纵向速度不变，即：<span class="math inline">\(V_y = C\)</span>。</li><li>忽略转向系统的影响，直接以前轮转角作为输入。</li><li>汽车横向加速度满足：<span class="math inline">\(a_y \leq 0.4g\)</span>，实验结果表明，对于小的侧偏角。此时轮胎侧偏力与侧偏角近似成正比。</li></ul><p>在上述假设下，汽车被简化为只有侧向和横摆两个自由度的两轮汽车模型。</p><p><img src="/images/resized_Dynamic_Bicycle_Model.png" alt="Fig 5 车辆二自由度动力学模型" style="width:60%;height:auto;"></p><p>由于质心侧偏角远小于车辆航向角和横摆角，在实际应用中可以认为航向角与横摆角相等,受力分析可以得到： <span class="math display">\[(F_{yf} \cos(\delta) - F_{xf} \sin(\delta)) + F_{yr} = m(\dot{v_y} + v_x \dot{\psi})\]</span></p><p><span class="math display">\[l_f (F_{yf} \cos(\delta) - F_{xf} \sin(\delta)) - l_r F_{yr} = I_z \ddot{\psi}\]</span> 这里横向加速度带有<span class="math inline">\(v_x\)</span>项，因为是矢量求导。</p><p>车辆的横向侧偏力可以写为</p><p><span class="math display">\[F_{yf} = 2 * c_f (\delta - \theta_{f}) \]</span></p><p><span class="math display">\[F_{yr} = 2 * c_r (-\theta_{r})\]</span></p><p><span class="math inline">\(c_f, c_r\)</span> 定义为侧偏刚度, 2 表示有两个轮子。</p><p>使用小角度假设， <span class="math display">\[\tan(\theta_{f}) = \frac{V_{yf} + l_{f}\dot{\psi}}{V_{x}}, \quad \tan(\theta_{r}) = \frac{V_{yr} - l_{r}\dot{\psi}}{V_{x}}\]</span></p><p><span class="math display">\[\theta_{f} = \frac{V_{yf} + l_{f}\dot{\psi}}{V_{x}}, \quad \theta_{r} = \frac{V_{yr} - l_{r}\dot{\psi}}{V_{x}}\]</span></p><p><span class="math display">\[\cos(\delta) \approx 1, \quad \sin(\delta) \approx 0\]</span></p><p>可以得到，</p><p><span class="math display">\[\begin{bmatrix}\dot{v}_y \\\ddot{\psi}\end{bmatrix}=\begin{bmatrix}-\frac{2c_f + 2c_r}{mv_x} &amp; \frac{2l_r c_r - 2l_f c_f}{mv_x} - v_x \\\frac{2l_r c_r - 2l_f c_f}{I_z v_x} &amp; -\frac{2l_f^2 c_f + 2l_r^2 c_r}{I_z v_x}\end{bmatrix}\begin{bmatrix}v_y \\\dot{\psi}\end{bmatrix}+\begin{bmatrix}\frac{2c_f}{m} \\\frac{2l_f c_f}{I_z}\end{bmatrix}\delta\]</span></p><p>定义误差：</p><p><span class="math display">\[\dot{\psi} = \frac{V_{x}}{R}\]</span></p><p><span class="math display">\[\ddot{e_{1}} = \ddot{y} + V_{x}\dot{\psi} - \frac{V_{x}^2}{R}\]</span></p><p><span class="math display">\[e_{2} = \psi - \psi_{des}\]</span></p><p>其中，<span class="math inline">\(e_1\)</span>为横向位置误差，<span class="math inline">\(e_2\)</span>为航向角误差。</p><p><span class="math display">\[\dot{x} = Ax + Bu + C\psi_{des}\]</span></p><p><span class="math display">\[X = \begin{bmatrix} e_1 &amp; e_2 &amp; \dot{e}_1 &amp; \dot{e}_2 \end{bmatrix}^T, \quad u = \delta\]</span></p><p><span class="math display">\[A = \begin{bmatrix}0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; -\frac{2c_f+2c_r}{mV_x} &amp; \frac{2c_f+2c_r}{m} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{mV_x} \\0 &amp; 0 &amp; 0 &amp; 1 \\0 &amp; \frac{2c_f\ell_f - 2c_r\ell_r}{I_zV_x} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{I_z} &amp; -\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix}\]</span></p><p><span class="math display">\[B = \begin{bmatrix}0 \\\frac{2c_f}{m} \\0 \\\frac{2c_f\ell_f}{I_z}\end{bmatrix} \delta, \quadC = \begin{bmatrix}0 \\\frac{-2c_f\ell_f + 2c_r\ell_r - V_x}{mV_x} \\0 \\-\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix}\]</span></p><p>综上，车辆二自由度动力学模型可以写为：</p><p><span class="math display">\[\frac{d}{dt} \begin{bmatrix}e_1 \\\dot{e}_1 \\e_2 \\\dot{e}_2\end{bmatrix} = \begin{bmatrix}0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; -\frac{2c_f+2c_r}{mV_x} &amp; \frac{2c_f+2c_r}{m} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{mV_x} \\0 &amp; 0 &amp; 0 &amp; 1 \\0 &amp; \frac{2c_f\ell_f - 2c_r\ell_r}{I_zV_x} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{I_z} &amp; -\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix}\begin{bmatrix}e_1 \\\dot{e}_1 \\e_2 \\\dot{e}_2\end{bmatrix}+\begin{bmatrix}0 \\\frac{2c_f}{m} \\0 \\\frac{2c_f\ell_f}{I_z}\end{bmatrix} \delta+\begin{bmatrix}0 \\\frac{-2c_f\ell_f + 2c_r\ell_r - V_x}{mV_x} \\0 \\-\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix} \dot{\psi}_{des}\]</span></p><h2 id="运动学和动力学参数标定">2.2 运动学和动力学参数标定</h2>]]></content>
      
      
      <categories>
          
          <category> 控制算法 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
