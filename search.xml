<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法与数据结构</title>
      <link href="/2024/08/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/08/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="图论">1 图论</h1><h2 id="图的定义">1.1 图的定义</h2><p><u>图（graph）</u>是一种非线性数据结构，由<u>顶点（vertex）</u>和<u>边（edge）</u>组成。我们可以将图 <span class="math inline">\(G\)</span> 抽象地表示为一组顶点 <span class="math inline">\(V\)</span> 和一组边 <span class="math inline">\(E\)</span> 的集合。以下示例展示了一个包含 5 个顶点和 7 条边的图。</p><p><span class="math display">\[\begin{aligned}V &amp; = \{ 1, 2, 3, 4, 5 \} \newlineE &amp; = \{ (1,2), (1,3), (1,5), (2,3), (2,4), (2,5), (4,5) \} \newlineG &amp; = \{ V, E \} \newline\end{aligned}\]</span></p><p>如果将顶点看作节点，将边看作连接各个节点的引用（指针），我们就可以将图看作一种从链表拓展而来的数据结构。如下图所示，<strong>相较于线性关系（链表）和分治关系（树），网络关系（图）的自由度更高</strong>，因而更为复杂。</p><figure><img src="https://github.com/krahets/hello-algo/raw/main/docs/chapter_graph/graph.assets/linkedlist_tree_graph.png" alt="链表、树、图之间的关系"><figcaption>链表、树、图之间的关系</figcaption></figure><h2 id="图的表示">1.2 图的表示</h2><p>图的常用表示方式包括“邻接矩阵”和“邻接表”。以下使用无向图进行举例。</p><h3 id="邻接矩阵">邻接矩阵</h3><p>设图的顶点数量为 <span class="math inline">\(n\)</span> ，<u>邻接矩阵（adjacency matrix）</u>使用一个 <span class="math inline">\(n \times n\)</span> 大小的矩阵来表示图，每一行（列）代表一个顶点，矩阵元素代表边，用 <span class="math inline">\(1\)</span> 或 <span class="math inline">\(0\)</span> 表示两个顶点之间是否存在边。</p><p>如下图所示，设邻接矩阵为 <span class="math inline">\(M\)</span>、顶点列表为 <span class="math inline">\(V\)</span> ，那么矩阵元素 <span class="math inline">\(M[i, j] = 1\)</span> 表示顶点 <span class="math inline">\(V[i]\)</span> 到顶点 <span class="math inline">\(V[j]\)</span> 之间存在边，反之 <span class="math inline">\(M[i, j] = 0\)</span> 表示两顶点之间无边。</p><figure><img src="https://github.com/krahets/hello-algo/raw/main/docs/chapter_graph/graph.assets/adjacency_matrix.png" alt="图的邻接矩阵表示"><figcaption>图的邻接矩阵表示</figcaption></figure><p>邻接矩阵具有以下特性。</p><ul><li>顶点不能与自身相连，因此邻接矩阵主对角线元素没有意义。</li><li>对于无向图，两个方向的边等价，此时邻接矩阵关于主对角线对称。</li><li>将邻接矩阵的元素从 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(0\)</span> 替换为权重，则可表示有权图。</li></ul><p>使用邻接矩阵表示图时，我们可以直接访问矩阵元素以获取边，因此增删查改操作的效率很高，时间复杂度均为 <span class="math inline">\(O(1)\)</span> 。然而，矩阵的空间复杂度为 <span class="math inline">\(O(n^2)\)</span> ，内存占用较多。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">createAdjMatrix</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">const</span> vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&amp; edges) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adjMatrix</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; edge : edges) &#123;<br>            adjMatrix[edge.first][edge.second] = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 如果是无向图，取消注释下一行</span><br>            <span class="hljs-comment">// adjMatrix[edge.second][edge.first] = 1;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> adjMatrix;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printAdjMatrix</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; adjMatrix)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; row : adjMatrix) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : row) &#123;<br>                cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>            cout &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Solution solution;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">edges</span>(m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        cin &gt;&gt; edges[i].first &gt;&gt; edges[i].second;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adjMatrix = solution.<span class="hljs-built_in">createAdjMatrix</span>(n, edges);<br>    solution.<span class="hljs-built_in">printAdjMatrix</span>(adjMatrix);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="邻接表">邻接表</h3><p><u>邻接表（adjacency list）</u>使用 <span class="math inline">\(n\)</span> 个链表来表示图，链表节点表示顶点。第 <span class="math inline">\(i\)</span> 个链表对应顶点 <span class="math inline">\(i\)</span> ，其中存储了该顶点的所有邻接顶点（与该顶点相连的顶点）。下图展示了一个使用邻接表存储的图的示例。</p><figure><img src="https://github.com/krahets/hello-algo/raw/main/docs/chapter_graph/graph.assets/adjacency_list.png" alt="图的邻接表表示"><figcaption>图的邻接表表示</figcaption></figure><p>邻接表仅存储实际存在的边，而边的总数通常远小于 <span class="math inline">\(n^2\)</span> ，因此它更加节省空间。然而，在邻接表中需要通过遍历链表来查找边，因此其时间效率不如邻接矩阵。</p><p>观察上图，<strong>邻接表结构与哈希表中的“链式地址”非常相似，因此我们也可以采用类似的方法来优化效率</strong>。比如当链表较长时，可以将链表转化为 AVL 树或红黑树，从而将时间效率从 <span class="math inline">\(O(n)\)</span> 优化至 <span class="math inline">\(O(\log n)\)</span> ；还可以把链表转换为哈希表，从而将时间复杂度降至 <span class="math inline">\(O(1)\)</span> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">createAdjList</span>(<span class="hljs-type">const</span> vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&amp; edges) &#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; adjList;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; edge : edges) &#123;<br>            adjList[edge.first].<span class="hljs-built_in">push_back</span>(edge.second);<br>            <span class="hljs-comment">// 如果是无向图，取消注释下一行</span><br>            <span class="hljs-comment">// adjList[edge.second].push_back(edge.first);</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> adjList;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printAdjList</span><span class="hljs-params">(<span class="hljs-type">const</span> unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; adjList)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; node : adjList) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Node &quot;</span> &lt;&lt; node.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : node.second) &#123;<br>                cout &lt;&lt; neighbor &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>            cout &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Solution solution;<br>    <span class="hljs-type">int</span> m;<br>    cin &gt;&gt; m;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">edges</span>(m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        cin &gt;&gt; edges[i].first &gt;&gt; edges[i].second;<br>    &#125;<br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; adjList = solution.<span class="hljs-built_in">createAdjList</span>(edges);<br>    solution.<span class="hljs-built_in">printAdjList</span>(adjList);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图的操作">1.3 图的操作</h2><ul><li>初始化</li><li>添加边，删除边</li><li>添加顶点，删除顶点 <figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-comment">/* 添加顶点 */</span><br><span class="hljs-type">void</span> addVertex(<span class="hljs-type">int</span> val) &#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 向顶点列表中添加新顶点的值</span><br>    vertices.push_back(val);<br>    <span class="hljs-comment">// 在邻接矩阵中添加一行</span><br>    adjMat.emplace_back(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>    <span class="hljs-comment">// 在邻接矩阵中添加一列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; &amp;<span class="hljs-built_in">row</span> : adjMat) &#123;<br>        <span class="hljs-built_in">row</span>.push_back(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 删除顶点 */</span><br><span class="hljs-type">void</span> removeVertex(<span class="hljs-type">int</span> index) &#123;<br>    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-built_in">size</span>()) &#123;<br>        throw out_of_range(<span class="hljs-string">&quot;顶点不存在&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 在顶点列表中移除索引 index 的顶点</span><br>    vertices.erase(vertices.begin() + index);<br>    <span class="hljs-comment">// 在邻接矩阵中删除索引 index 的行</span><br>    adjMat.erase(adjMat.begin() + index);<br>    <span class="hljs-comment">// 在邻接矩阵中删除索引 index 的列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; &amp;<span class="hljs-built_in">row</span> : adjMat) &#123;<br>        <span class="hljs-built_in">row</span>.erase(<span class="hljs-built_in">row</span>.begin() + index);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 添加边 */</span><br><span class="hljs-comment">// 参数 i, j 对应 vertices 元素索引</span><br><span class="hljs-type">void</span> addEdge(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123;<br>    <span class="hljs-comment">// 索引越界与相等处理</span><br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= <span class="hljs-built_in">size</span>() || j &gt;= <span class="hljs-built_in">size</span>() || i == j) &#123;<br>        throw out_of_range(<span class="hljs-string">&quot;顶点不存在&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 在无向图中，邻接矩阵关于主对角线对称，即满足 (i, j) == (j, i)</span><br>    adjMat[i][j] = <span class="hljs-number">1</span>;<br>    adjMat[j][i] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/* 删除边 */</span><br><span class="hljs-comment">// 参数 i, j 对应 vertices 元素索引</span><br><span class="hljs-type">void</span> removeEdge(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123;<br>    <span class="hljs-comment">// 索引越界与相等处理</span><br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= <span class="hljs-built_in">size</span>() || j &gt;= <span class="hljs-built_in">size</span>() || i == j) &#123;<br>        throw out_of_range(<span class="hljs-string">&quot;顶点不存在&quot;</span>);<br>    &#125;<br>    adjMat[i][j] = <span class="hljs-number">0</span>;<br>    adjMat[j][i] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="图的遍历">1.4 图的遍历</h2><h3 id="bfs广度优先搜索">BFS(广度优先搜索)</h3><p><strong>广度优先遍历是一种由近及远的遍历方式，从某个节点出发，始终优先访问距离最近的顶点，并一层层向外扩张</strong>。如下图所示，从左上角顶点出发，首先遍历该顶点的所有邻接顶点，然后遍历下一个顶点的所有邻接顶点，以此类推，直至所有顶点访问完毕。</p><figure><img src="https://github.com/krahets/hello-algo/raw/main/docs//chapter_graph/graph_traversal.assets/graph_bfs.png" alt="图的广度优先遍历"><figcaption>图的广度优先遍历</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 节点结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> x; <span class="hljs-comment">// 节点的索引</span><br>    shared_ptr&lt;Node&gt; parent; <span class="hljs-comment">// 父节点指针</span><br><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> x, shared_ptr&lt;Node&gt; parent = <span class="hljs-literal">nullptr</span>) <br>        : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">parent</span>(parent) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 检查节点是否合法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidNode</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> grid[x][v] == <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// BFS算法实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, vector&lt;shared_ptr&lt;Node&gt;&gt;&amp; path, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// openList普通队列</span><br>    queue&lt;shared_ptr&lt;Node&gt;&gt; openList;<br>    <span class="hljs-comment">// closedList数组，记录已访问节点</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">closedList</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br><br>    <span class="hljs-comment">// 初始化起始节点</span><br>    shared_ptr&lt;Node&gt; startNode = <span class="hljs-built_in">make_shared</span>&lt;Node&gt;(start);<br>    openList.<span class="hljs-built_in">push</span>(startNode);<br><br>    <span class="hljs-comment">// BFS算法主循环</span><br>    <span class="hljs-keyword">while</span> (!openList.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// 获取队列中的第一个节点</span><br>        shared_ptr&lt;Node&gt; current = openList.<span class="hljs-built_in">front</span>();<br>        openList.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-comment">// 如果当前节点是目标节点，构建路径并返回</span><br>        <span class="hljs-keyword">if</span> (current-&gt;x == end) &#123;<br>            <span class="hljs-keyword">while</span> (current) &#123;<br>                path.<span class="hljs-built_in">push_back</span>(current);<br>                current = current-&gt;parent;<br>            &#125;<br>            <span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 将当前节点标记为已访问</span><br>        closedList[current-&gt;x] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 获取当前节点的所有nextNode</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; v++) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isValidNode</span>(current-&gt;x, v, grid) || closedList[v]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            shared_ptr&lt;Node&gt; newNode = <span class="hljs-built_in">make_shared</span>&lt;Node&gt;(v, current); <span class="hljs-comment">// 创建新节点</span><br>            openList.<span class="hljs-built_in">push</span>(newNode); <span class="hljs-comment">// 将新节点加入队列</span><br>            closedList[v] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记新节点为已访问</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, p1, p2;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        cin &gt;&gt; p1 &gt;&gt; p2;<br>        grid[p1][p2] = <span class="hljs-number">1</span>;<br>        grid[p2][p1] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 无向图</span><br>    &#125;<br><br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> end = n;<br>    vector&lt;shared_ptr&lt;Node&gt;&gt; path;<br><br>    <span class="hljs-built_in">bfs</span>(grid, start, end, path, n);<br><br>    <span class="hljs-comment">// 打印路径长度</span><br>    <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">empty</span>()) &#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &lt;&lt; endl; <span class="hljs-comment">// 因为路径长度是节点数-1</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="dfs深度优先搜索">DFS(深度优先搜索)</h3><p><strong>深度优先遍历是一种优先走到底、无路可走再回头的遍历方式</strong>。如下图所示，从左上角顶点出发，访问当前顶点的某个邻接顶点，直到走到尽头时返回，再继续走到尽头并返回，以此类推，直至所有顶点遍历完成。</p><figure><img src="https://github.com/krahets/hello-algo/raw/main/docs//chapter_graph/graph_traversal.assets/graph_dfs.png" alt="图的深度优先遍历"><figcaption>图的深度优先遍历</figcaption></figure><h2 id="图的遍历基本题型">1.5 图的遍历基本题型</h2><ul><li>有向图的完全可达性</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(visited[x])&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    visited[x] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (graph.<span class="hljs-built_in">find</span>(x) != graph.<span class="hljs-built_in">end</span>())&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i : graph.<span class="hljs-built_in">at</span>(x))&#123;<br>            <span class="hljs-built_in">dfs</span>(graph, i, visited);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; graph;<br>    <span class="hljs-type">int</span> s, t;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        graph[s].<span class="hljs-built_in">push_back</span>(t);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n<span class="hljs-number">+1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">1</span>, visited);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!visited[i])&#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>所有可达路径 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; n, <span class="hljs-type">int</span> x, vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; result)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x == n) &#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (graph.<span class="hljs-built_in">find</span>(x) != graph.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i : graph.<span class="hljs-built_in">at</span>(x) &#123;  <span class="hljs-comment">//使用[x]的话当键不存在，将抛出异常而而插入默认值修改graph</span><br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">dfs</span>(graph, n, i, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-built_in">main</span>() &#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; graph;<br>    <span class="hljs-type">int</span> s, t;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        graph[s].<span class="hljs-built_in">push_back</span>(t);<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dfs</span>(graph, n, <span class="hljs-number">1</span>, path, result);<br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; path : result) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>                cout &lt;&lt; path[i] &lt;&lt; endl;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cout &lt;&lt; path[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li>岛屿数量（DFS） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 节点结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> x, y; <span class="hljs-comment">// 节点的坐标</span><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 检查节点是否合法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidNode</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; grid.<span class="hljs-built_in">size</span>() &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; grid[x][y] == <span class="hljs-number">1</span> &amp;&amp; !visited[x][y]);<br>&#125;<br><br><span class="hljs-comment">// 使用BFS标记所有相连的1为已访问</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> startX, <span class="hljs-type">int</span> startY)</span> </span>&#123;<br>    <span class="hljs-comment">// 定义四个方向的移动</span><br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; directions = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    queue&lt;shared_ptr&lt;Node&gt;&gt; openList;<br>    openList.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;Node&gt;(startX, startY));<br>    visited[startX][startY] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// BFS算法主循环</span><br>    <span class="hljs-keyword">while</span> (!openList.<span class="hljs-built_in">empty</span>()) &#123;<br>        shared_ptr&lt;Node&gt; current = openList.<span class="hljs-built_in">front</span>();<br>        openList.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; dir : directions) &#123;<br>            <span class="hljs-type">int</span> newX = current-&gt;x + dir.first;<br>            <span class="hljs-type">int</span> newY = current-&gt;y + dir.second;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValidNode</span>(newX, newY, grid, visited)) &#123;<br>                visited[newX][newY] = <span class="hljs-literal">true</span>;<br>                openList.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;Node&gt;(newX, newY));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (grid.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> numIslands = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> rows = grid.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> cols = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(rows, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(cols, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[i][j]) &#123;<br>                <span class="hljs-built_in">bfs</span>(grid, visited, i, j);<br>                ++numIslands;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> numIslands;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            cin &gt;&gt; grid[i][j];<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-built_in">numIslands</span>(grid) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>岛屿数量（DFS） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 节点结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> x, y; <span class="hljs-comment">// 节点的坐标</span><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 检查节点是否合法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidNode</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; grid.<span class="hljs-built_in">size</span>() &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; grid[x][y] == <span class="hljs-number">1</span> &amp;&amp; !visited[x][y]);<br>&#125;<br><br><span class="hljs-comment">// 使用DFS标记所有相连的1为已访问</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> startX, <span class="hljs-type">int</span> startY)</span> </span>&#123;<br>    <span class="hljs-comment">// 定义四个方向的移动</span><br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; directions = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    visited[startX][startY] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; dir : directions) &#123;<br>        <span class="hljs-type">int</span> newX = startX + dir.first;<br>        <span class="hljs-type">int</span> newY = startY + dir.second;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValidNode</span>(newX, newY, grid, visited)) &#123;<br>            <span class="hljs-built_in">dfs</span>(grid, visited, newX, newY);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (grid.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> numIslands = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> rows = grid.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> cols = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(rows, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(cols, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[i][j]) &#123;<br>                <span class="hljs-built_in">dfs</span>(grid, visited, i, j);<br>                ++numIslands;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> numIslands;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            cin &gt;&gt; grid[i][j];<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-built_in">numIslands</span>(grid) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>沉没孤岛（BFS） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> mark)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (visited[i][j] || graph[i][j] == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    visited[i][j] = mark; <br>    <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) <span class="hljs-built_in">dfs</span>(graph, visited, i - <span class="hljs-number">1</span>, j, mark);<br>    <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; graph[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">dfs</span>(graph, visited, i, j + <span class="hljs-number">1</span>, mark);<br>    <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; graph.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">dfs</span>(graph, visited, i + <span class="hljs-number">1</span>, j, mark);<br>    <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) <span class="hljs-built_in">dfs</span>(graph, visited, i, j - <span class="hljs-number">1</span>, mark);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            cin &gt;&gt; graph[i][j]; <br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[i][<span class="hljs-number">0</span>] &amp;&amp; graph[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(graph, visited, i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!visited[i][m<span class="hljs-number">-1</span>] &amp;&amp; graph[i][m<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(graph, visited, i, m<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[<span class="hljs-number">0</span>][j] &amp;&amp; graph[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(graph, visited, <span class="hljs-number">0</span>, j, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!visited[n<span class="hljs-number">-1</span>][j] &amp;&amp; graph[n<span class="hljs-number">-1</span>][j] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(graph, visited, n<span class="hljs-number">-1</span>, j, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; graph[i][j] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">dfs</span>(graph, visited, i, j, <span class="hljs-number">2</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (visited[i][j] == <span class="hljs-number">2</span>) &#123;<br>                graph[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            cout &lt;&lt; graph[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>其余岛屿问题（岛屿的最大面积、孤岛的总面积、建造最大工岛、字符串接龙、岛屿的周长）</p></li></ul><h2 id="并查集">1.6 并查集</h2><p>并查集常用来解决连通性问题，当我们需要判断两个元素是否在同一个集合里的时候，可以使用并查集。 并查集主要有两个功能：</p><ul><li>将两个元素添加到一个集合中。</li><li>判断两个元素在不在同一个集合 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (n, <span class="hljs-number">0</span>); <span class="hljs-comment">// C++里的一种数组结构</span><br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 路径压缩</span><br>&#125;<br><br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="并查集基本题型">1.7 并查集基本题型</h2><ul><li>寻找存在的路径 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">father</span><span class="hljs-params">(<span class="hljs-number">1001</span>,<span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">if</span>(u == v) <span class="hljs-keyword">return</span>;<br>    father[u] = v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> m;<br>    cin &gt;&gt; m;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">int</span> s, t;<br>    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; last_edge;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-built_in">join</span>(s, t);<br>    &#125;<br>    cin &gt;&gt; s &gt;&gt; t;<br>    cout &lt;&lt; <span class="hljs-built_in">isSame</span>(s, t) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>冗余连接 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">father</span><span class="hljs-params">(<span class="hljs-number">1001</span>,<span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">if</span>(u == v) <span class="hljs-keyword">return</span>;<br>    father[u] = v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">int</span> s, t;<br>    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; last_edge;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isSame</span>(s, t))&#123;<br>            last_edge = &#123;s, t&#125;;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">join</span>(s, t);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; last_edge.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; last_edge.second &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>其余并查集问题（冗余连接II）</li></ul><h2 id="最小生成树">1.8 最小生成树</h2><ul><li>Prim算法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> e, v; <span class="hljs-comment">// e是节点数，v是边数</span><br>    cin &gt;&gt; e &gt;&gt; v;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(e<span class="hljs-number">+1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(e<span class="hljs-number">+1</span>, INT_MAX));<br>    <br>    <span class="hljs-comment">// 读取边的输入，v1和v2是两个节点，val是它们之间的边的权重</span><br>    <span class="hljs-type">int</span> v1, v2, val;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v; i++) &#123;<br>        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;<br>        grid[v1][v2] = val;<br>        grid[v2][v1] = val;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 用于记录每个节点是否已经在生成树中</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">isTree</span><span class="hljs-params">(e<span class="hljs-number">+1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// 用于记录每个节点到生成树的最短距离</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(e<span class="hljs-number">+1</span>, INT_MAX)</span></span>;<br>    <br>    <span class="hljs-comment">// 从第一个节点开始</span><br>    minDist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> totalWeight = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录生成树的总权重</span><br><br>    <span class="hljs-comment">// Prim算法的主循环</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= e; i++) &#123;<br>        <span class="hljs-comment">// 第一步：选距离生成树最近的节点</span><br>        <span class="hljs-type">int</span> minDistance = INT_MAX;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= e; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!isTree[j] &amp;&amp; minDist[j] &lt; minDistance) &#123;<br>                minDistance = minDist[j];<br>                u = j;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 将选中的节点u加入生成树</span><br>        isTree[u] = <span class="hljs-literal">true</span>;<br>        totalWeight += minDistance;<br><br>        <span class="hljs-comment">// 更新非生成树节点到生成树的距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= e; k++) &#123;<br>            <span class="hljs-keyword">if</span> (!isTree[k] &amp;&amp; grid[u][k] &lt; minDist[k]) &#123;<br>                minDist[k] = grid[u][k];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 输出生成树的总权重</span><br>    cout &lt;&lt; totalWeight &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>Kruskal算法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// l,r为 边两边的节点，val为边的数值</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> l, r, val;<br>&#125;;<br><br><span class="hljs-comment">// 节点数量</span><br><span class="hljs-type">int</span> n = <span class="hljs-number">10001</span>;<br><span class="hljs-comment">// 并查集标记节点关系的数组</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">father</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// 节点编号是从1开始的，n要大一些</span><br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 并查集的查找操作</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 路径压缩</span><br>&#125;<br><br><span class="hljs-comment">// 并查集的加入集合</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> v, e;<br>    <span class="hljs-type">int</span> v1, v2, val;<br>    vector&lt;Edge&gt; edges;<br>    <span class="hljs-type">int</span> result_val = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; v &gt;&gt; e;<br>    <span class="hljs-keyword">while</span> (e--) &#123;<br>        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;<br>        edges.<span class="hljs-built_in">push_back</span>(&#123;v1, v2, val&#125;);<br>    &#125;<br><br>    <span class="hljs-comment">// 执行Kruskal算法</span><br>    <span class="hljs-comment">// 按边的权值对边进行从小到大排序</span><br>    <span class="hljs-built_in">sort</span>(edges.<span class="hljs-built_in">begin</span>(), edges.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> Edge&amp; a, <span class="hljs-type">const</span> Edge&amp; b) &#123;<br>            <span class="hljs-keyword">return</span> a.val &lt; b.val;<br>    &#125;);<br><br>    <span class="hljs-comment">// 并查集初始化</span><br>    <span class="hljs-built_in">init</span>();<br><br>    <span class="hljs-comment">// 从头开始遍历边</span><br>    <span class="hljs-keyword">for</span> (Edge edge : edges) &#123;<br>        <span class="hljs-comment">// 并查集，搜出两个节点的祖先</span><br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(edge.l);<br>        <span class="hljs-type">int</span> y = <span class="hljs-built_in">find</span>(edge.r);<br><br>        <span class="hljs-comment">// 如果祖先不同，则不在同一个集合</span><br>        <span class="hljs-keyword">if</span> (x != y) &#123;<br>            result_val += edge.val; <span class="hljs-comment">// 这条边可以作为生成树的边</span><br>            <span class="hljs-built_in">join</span>(x, y); <span class="hljs-comment">// 两个节点加入到同一个集合</span><br>        &#125;<br>    &#125;<br>    cout &lt;&lt; result_val &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="拓扑排序">1.8 拓扑排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> m, n, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 记录每个文件的入度</span><br><br>    unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; umap;<span class="hljs-comment">// 记录文件依赖关系</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-comment">// 记录结果</span><br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-comment">// s-&gt;t，先有s才能有t</span><br>        cin &gt;&gt; s &gt;&gt; t;<br>        inDegree[t]++; <span class="hljs-comment">// t的入度加一</span><br>        umap[s].<span class="hljs-built_in">push_back</span>(t); <span class="hljs-comment">// 记录s指向哪些文件</span><br>    &#125;<br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 入度为0的文件，可以作为开头，先加入队列</span><br>        <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) que.<span class="hljs-built_in">push</span>(i);<br>        <span class="hljs-comment">//cout &lt;&lt; inDegree[i] &lt;&lt; endl;</span><br>    &#125;<br>    <span class="hljs-comment">// int count = 0;</span><br>    <span class="hljs-keyword">while</span> (que.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-type">int</span>  cur = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 当前选中的文件</span><br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//count++;</span><br>        result.<span class="hljs-built_in">push_back</span>(cur);<br>        vector&lt;<span class="hljs-type">int</span>&gt; files = umap[cur]; <span class="hljs-comment">//获取该文件指向的文件</span><br>        <span class="hljs-keyword">if</span> (files.<span class="hljs-built_in">size</span>() != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// cur有后续文件</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; files.<span class="hljs-built_in">size</span>(); i++) &#123;<br>                inDegree[files[i]] --; <span class="hljs-comment">// cur的指向的文件入度-1</span><br>                <span class="hljs-keyword">if</span>(inDegree[files[i]] == <span class="hljs-number">0</span>) que.<span class="hljs-built_in">push</span>(files[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == n) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) cout &lt;&lt; result[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        cout &lt;&lt; result[n - <span class="hljs-number">1</span>];<br>    &#125; <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="dijkstra算法">1.9 Dijkstra算法</h2><ul><li><p>参加科学大会 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 节点结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> x; <span class="hljs-comment">// 节点的索引</span><br>    <span class="hljs-type">double</span> g; <span class="hljs-comment">// g是起点到当前节点的成本</span><br>    shared_ptr&lt;Node&gt; parent; <span class="hljs-comment">// 父节点指针</span><br><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">double</span> g, shared_ptr&lt;Node&gt; parent = <span class="hljs-literal">nullptr</span>) <br>        : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">g</span>(g), <span class="hljs-built_in">parent</span>(parent) &#123;&#125;<br><br>    <span class="hljs-comment">// 获取g值</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getG</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> g;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 节点比较结构体，用于优先队列</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CompareNode</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> shared_ptr&lt;Node&gt;&amp; n1, <span class="hljs-type">const</span> shared_ptr&lt;Node&gt;&amp; n2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n1-&gt;<span class="hljs-built_in">getG</span>() &gt; n2-&gt;<span class="hljs-built_in">getG</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 检查节点是否合法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidNode</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> grid[x][v] != INT_MAX;<br>&#125;<br><br><span class="hljs-comment">// 坐标转换为字符串键</span><br><span class="hljs-function">string <span class="hljs-title">toString</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(x);<br>&#125;<br><br><span class="hljs-comment">// Dijkstra算法实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, vector&lt;shared_ptr&lt;Node&gt;&gt;&amp; path, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// openList优先队列，按g值排序</span><br>    priority_queue&lt;shared_ptr&lt;Node&gt;, vector&lt;shared_ptr&lt;Node&gt;&gt;, CompareNode&gt; openList_pq;<br>    <span class="hljs-comment">// closedList集合，记录已访问节点</span><br>    unordered_map&lt;string, shared_ptr&lt;Node&gt;&gt; closedList_map;<br>    <span class="hljs-comment">// 用来保存节点指针的映射，方便查找和更新</span><br>    unordered_map&lt;string, shared_ptr&lt;Node&gt;&gt; openList_map;<br><br>    <span class="hljs-comment">// 初始化起始节点</span><br>    shared_ptr&lt;Node&gt; startNode = <span class="hljs-built_in">make_shared</span>&lt;Node&gt;(start, <span class="hljs-number">0</span>);<br>    openList_pq.<span class="hljs-built_in">push</span>(startNode);<br>    openList_map[<span class="hljs-built_in">toString</span>(start)] = startNode;<br><br>    <span class="hljs-comment">// Dijkstra算法主循环</span><br>    <span class="hljs-keyword">while</span> (!openList_pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// 获取openList中g值最小的节点</span><br>        shared_ptr&lt;Node&gt; current = openList_pq.<span class="hljs-built_in">top</span>();<br>        openList_pq.<span class="hljs-built_in">pop</span>();<br>        openList_map.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">toString</span>(current-&gt;x));<br><br>        <span class="hljs-comment">// 如果当前节点是目标节点，构建路径并返回</span><br>        <span class="hljs-keyword">if</span> (current-&gt;x == end) &#123;<br>            <span class="hljs-keyword">while</span> (current) &#123;<br>                path.<span class="hljs-built_in">push_back</span>(current);<br>                current = current-&gt;parent;<br>            &#125;<br>            <span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 将当前节点标记为已访问</span><br>        closedList_map.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">toString</span>(current-&gt;x), current);<br><br>        <span class="hljs-comment">// 获取当前节点的所有nextNode</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; v++) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isValidNode</span>(current-&gt;x, v, grid) || closedList_map.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">toString</span>(v))) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">double</span> temp_g = current-&gt;g + grid[current-&gt;x][v];<br><br>            <span class="hljs-comment">// 检查openList中是否已有该节点</span><br>            <span class="hljs-keyword">if</span> (openList_map.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">toString</span>(v)) == openList_map.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-comment">// 如果邻居节点不在openList中，创建新节点并加入openList_pq</span><br>                shared_ptr&lt;Node&gt; newNode = <span class="hljs-built_in">make_shared</span>&lt;Node&gt;(v, temp_g, current); <span class="hljs-comment">// 创建新节点</span><br>                openList_pq.<span class="hljs-built_in">push</span>(newNode); <span class="hljs-comment">// 将新节点加入openList_pq</span><br>                openList_map.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">toString</span>(v), newNode); <span class="hljs-comment">// 将新节点加入openList_map</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                shared_ptr&lt;Node&gt; existingNode = openList_map[<span class="hljs-built_in">toString</span>(v)];<br>                <span class="hljs-comment">// 如果新路径更优，更新节点信息</span><br>                <span class="hljs-keyword">if</span> (temp_g &lt; existingNode-&gt;g) &#123;<br>                    existingNode-&gt;g = temp_g;<br>                    existingNode-&gt;parent = current;<br>                    openList_pq.<span class="hljs-built_in">push</span>(existingNode); <span class="hljs-comment">// 将更新后的节点重新加入优先队列</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, INT_MAX));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        grid[p1][p2] = val;<br>    &#125;<br><br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> end = n;<br>    vector&lt;shared_ptr&lt;Node&gt;&gt; path;<br><br>    <span class="hljs-built_in">dijkstra</span>(grid, start, end, path, n);<br><br>    <span class="hljs-comment">// 打印路径</span><br>    <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">empty</span>()) &#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; path.<span class="hljs-built_in">back</span>()-&gt;g &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure> ## 1.10 A*算法</p></li><li><p>骑士的攻击 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> BOARD_SIZE = <span class="hljs-number">1000</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-type">double</span> g, h;<br>    shared_ptr&lt;Node&gt; parent;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">double</span> g, <span class="hljs-type">double</span> h, shared_ptr&lt;Node&gt; parent = <span class="hljs-literal">nullptr</span>)<br>        : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y), <span class="hljs-built_in">g</span>(g), <span class="hljs-built_in">h</span>(h), <span class="hljs-built_in">parent</span>(parent) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getF</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> g + h;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> shared_ptr&lt;Node&gt;&amp; n1, <span class="hljs-type">const</span> shared_ptr&lt;Node&gt;&amp; n2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n1-&gt;<span class="hljs-built_in">getF</span>() &gt; n2-&gt;<span class="hljs-built_in">getF</span>();<br>    &#125;<br>&#125;; <br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">heuristic</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(x1 - x2, <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(y1 - y2, <span class="hljs-number">2</span>);<br>&#125;<br><br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">nextNodeGenerator</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        &#123;x + <span class="hljs-number">2</span>, y - <span class="hljs-number">1</span>&#125;,<br>        &#123;x - <span class="hljs-number">2</span>, y + <span class="hljs-number">1</span>&#125;,<br>        &#123;x + <span class="hljs-number">1</span>, y - <span class="hljs-number">2</span>&#125;,<br>        &#123;x - <span class="hljs-number">1</span>, y + <span class="hljs-number">2</span>&#125;,<br>        &#123;x - <span class="hljs-number">2</span>, y - <span class="hljs-number">1</span>&#125;,<br>        &#123;x + <span class="hljs-number">2</span>, y + <span class="hljs-number">1</span>&#125;,<br>        &#123;x - <span class="hljs-number">1</span>, y - <span class="hljs-number">2</span>&#125;,<br>        &#123;x + <span class="hljs-number">1</span>, y + <span class="hljs-number">2</span>&#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidNode</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (x &gt;= <span class="hljs-number">1</span> &amp;&amp; x &lt;= BOARD_SIZE &amp;&amp; y &gt;= <span class="hljs-number">1</span> &amp;&amp; y &lt;= BOARD_SIZE);<br>&#125;<br><br><span class="hljs-function">string <span class="hljs-title">toString</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(x) + <span class="hljs-string">&quot;_&quot;</span> + <span class="hljs-built_in">to_string</span>(y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">aStar</span><span class="hljs-params">(shared_ptr&lt;Node&gt; startNode, shared_ptr&lt;Node&gt; endNode, <span class="hljs-type">int</span>&amp; result)</span> </span>&#123;<br>    priority_queue&lt;shared_ptr&lt;Node&gt;, vector&lt;shared_ptr&lt;Node&gt;&gt;, cmp&gt; openList_pq;<br>    unordered_map&lt;string, shared_ptr&lt;Node&gt;&gt; closeList;<br><br>    openList_pq.<span class="hljs-built_in">push</span>(startNode);<br><br>    <span class="hljs-keyword">while</span> (!openList_pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        shared_ptr&lt;Node&gt; current = openList_pq.<span class="hljs-built_in">top</span>();<br>        openList_pq.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">toString</span>(current-&gt;x, current-&gt;y) == <span class="hljs-built_in">toString</span>(endNode-&gt;x, endNode-&gt;y)) &#123; <br>            <span class="hljs-keyword">while</span> (current) &#123;<br>                result++;<br>                current = current-&gt;parent;<br>            &#125;<br>            result--;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        closeList.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">toString</span>(current-&gt;x, current-&gt;y), current); <br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; nextNodes = <span class="hljs-built_in">nextNodeGenerator</span>(current-&gt;x, current-&gt;y);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; nextNode : nextNodes) &#123;<br>            <span class="hljs-type">int</span> nextX = nextNode.first;<br>            <span class="hljs-type">int</span> nextY = nextNode.second;<br>            string nextKey = <span class="hljs-built_in">toString</span>(nextX, nextY); <br><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isValidNode</span>(nextX, nextY) || closeList.<span class="hljs-built_in">find</span>(nextKey) != closeList.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">double</span> nextG = current-&gt;g + <span class="hljs-built_in">heuristic</span>(current-&gt;x, current-&gt;y, nextX, nextY);<br>            <span class="hljs-type">double</span> nextH = <span class="hljs-built_in">heuristic</span>(nextX, nextY, endNode-&gt;x, endNode-&gt;y);<br>            shared_ptr&lt;Node&gt; newNode = <span class="hljs-built_in">make_shared</span>&lt;Node&gt;(nextX, nextY, nextG, nextH, current);<br>            openList_pq.<span class="hljs-built_in">push</span>(newNode);<br>        &#125;<br>    &#125;<br>    result = <span class="hljs-number">-1</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> startX, startY, endX, endY;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; startX &gt;&gt; startY &gt;&gt; endX &gt;&gt; endY;<br>        shared_ptr&lt;Node&gt; startNode = <span class="hljs-built_in">make_shared</span>&lt;Node&gt;(startX, startY, <span class="hljs-number">0</span>, <span class="hljs-built_in">heuristic</span>(startX, startY, endX, endY));<br>        shared_ptr&lt;Node&gt; endNode = <span class="hljs-built_in">make_shared</span>&lt;Node&gt;(endX, endY, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">aStar</span>(startNode, endNode, result);<br>        <span class="hljs-keyword">if</span> (result != <span class="hljs-number">-1</span>) &#123;<br>            cout &lt;&lt; result &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;No path found.&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></p></li><li><p>A*基本实现</p></li></ul><p><strong><code>openlist_pq</code>（优先队列）</strong>：</p><p>作用：存储尚未被扩展的节点，并根据节点的 f 值（总代价，即 g + h）进行排序。</p><p>详细描述：优先队列的作用是确保每次从队列中取出的节点都是当前代价最小的节点，从而保证算法优先扩展最有可能通向最优解的路径。</p><p><strong><code>closelist</code>（关闭集合）</strong>：</p><p>作用：记录已经被扩展和处理过的节点，避免重复处理。</p><p>详细描述：<code>closelist</code> 是一个哈希表，用于存储所有已处理过的节点。通过检查 <code>closelist</code>，算法可以防止重复扩展同一个节点，避免死循环和无效计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 节点结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> x, y; <span class="hljs-comment">// 节点的坐标</span><br>    <span class="hljs-type">double</span> g, h; <span class="hljs-comment">// g是起点到当前节点的成本，h是启发函数的估算成本</span><br>    shared_ptr&lt;Node&gt; parent; <span class="hljs-comment">// 父节点指针</span><br><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">double</span> g, <span class="hljs-type">double</span> h, shared_ptr&lt;Node&gt; parent = <span class="hljs-literal">nullptr</span>) <br>        : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y), <span class="hljs-built_in">g</span>(g), <span class="hljs-built_in">h</span>(h), <span class="hljs-built_in">parent</span>(parent) &#123;&#125;<br><br>    <span class="hljs-comment">// 获取f值，f = g + h</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getF</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> g + h;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 节点比较结构体，用于优先队列</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CompareNode</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> shared_ptr&lt;Node&gt;&amp; n1, <span class="hljs-type">const</span> shared_ptr&lt;Node&gt;&amp; n2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n1-&gt;<span class="hljs-built_in">getF</span>() &gt; n2-&gt;<span class="hljs-built_in">getF</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 欧氏距离启发函数</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">heuristic</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">pow</span>(x1 - x2, <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(y1 - y2, <span class="hljs-number">2</span>));<br>&#125;<br><br><span class="hljs-comment">// 检查节点是否合法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidNode</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-type">int</span> rows = grid.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> cols = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">return</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols &amp;&amp; grid[x][y] == <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// 生成nextNode</span><br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">NextNodeGenerator</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        &#123;x - <span class="hljs-number">1</span>, y&#125;,<br>        &#123;x + <span class="hljs-number">1</span>, y&#125;,<br>        &#123;x, y - <span class="hljs-number">1</span>&#125;,<br>        &#123;x, y + <span class="hljs-number">1</span>&#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">// 坐标转换为字符串键</span><br><span class="hljs-function">string <span class="hljs-title">toString</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(x) + <span class="hljs-string">&quot;_&quot;</span> + <span class="hljs-built_in">to_string</span>(y);<br>&#125;<br><br><span class="hljs-comment">// A*算法实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">aStar</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> startX, <span class="hljs-type">int</span> startY, <span class="hljs-type">int</span> endX, <span class="hljs-type">int</span> endY, vector&lt;shared_ptr&lt;Node&gt;&gt;&amp; path)</span> </span>&#123;<br>    <span class="hljs-comment">// openList优先队列，按f值排序，确保每次扩展的都是当前总代价最小的节点</span><br>    priority_queue&lt;shared_ptr&lt;Node&gt;, vector&lt;shared_ptr&lt;Node&gt;&gt;, CompareNode&gt; openList_pq;<br>    <span class="hljs-comment">// closedList集合，记录已经处理过的节点，防止重复处理</span><br>    unordered_map&lt;string, shared_ptr&lt;Node&gt;&gt; closeList;<br><br>    <span class="hljs-comment">// 初始化起始节点</span><br>    shared_ptr&lt;Node&gt; startNode = <span class="hljs-built_in">make_shared</span>&lt;Node&gt;(startX, startY, <span class="hljs-number">0</span>, <span class="hljs-built_in">heuristic</span>(startX, startY, endX, endY));<br>    openList_pq.<span class="hljs-built_in">push</span>(startNode);<br><br>    <span class="hljs-comment">// A*算法主循环</span><br>    <span class="hljs-keyword">while</span> (!openList_pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// 获取openList中f值最小的节点</span><br>        shared_ptr&lt;Node&gt; current = openList_pq.<span class="hljs-built_in">top</span>();<br>        openList_pq.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-comment">// 如果当前节点是目标节点，构建路径并返回</span><br>        <span class="hljs-keyword">if</span> (current-&gt;x == endX &amp;&amp; current-&gt;y == endY) &#123;<br>            <span class="hljs-keyword">while</span> (current) &#123;<br>                path.<span class="hljs-built_in">push_back</span>(current);<br>                current = current-&gt;parent;<br>            &#125;<br>            <span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 将当前节点标记为已访问</span><br>        closeList.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">toString</span>(current-&gt;x, current-&gt;y), current);<br><br>        <span class="hljs-comment">// 获取当前节点的所有nextNode</span><br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; nextNodes = <span class="hljs-built_in">NextNodeGenerator</span>(current-&gt;x, current-&gt;y);<br><br>        <span class="hljs-comment">// 遍历所有nextNode</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; nextNode : nextNodes) &#123;<br>            <span class="hljs-type">int</span> nx = nextNode.first;<br>            <span class="hljs-type">int</span> ny = nextNode.second;<br><br>            <span class="hljs-comment">// 如果nextNode无效或已访问，跳过</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isValidNode</span>(grid, nx, ny) || closeList.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">toString</span>(nx, ny)) != closeList.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">double</span> temp_g = current-&gt;g + <span class="hljs-built_in">heuristic</span>(current-&gt;x, current-&gt;y, nx, ny);<br>            <span class="hljs-type">double</span> h = <span class="hljs-built_in">heuristic</span>(nx, ny, endX, endY); <span class="hljs-comment">// 计算h值</span><br>            shared_ptr&lt;Node&gt; newNode = <span class="hljs-built_in">make_shared</span>&lt;Node&gt;(nx, ny, temp_g, h, current); <span class="hljs-comment">// 创建新节点</span><br>            openList_pq.<span class="hljs-built_in">push</span>(newNode); <span class="hljs-comment">// 将新节点加入openList_pq</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 5x5 网格表示，0为可通行，1为障碍物</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; grid = &#123;<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;<br>    &#125;;<br><br>    <span class="hljs-type">int</span> startX = <span class="hljs-number">0</span>, startY = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> endX = <span class="hljs-number">4</span>, endY = <span class="hljs-number">4</span>;<br>    vector&lt;shared_ptr&lt;Node&gt;&gt; path;<br><br>    <span class="hljs-built_in">aStar</span>(grid, startX, startY, endX, endY, path);<br><br>    <span class="hljs-comment">// 打印路径</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; node : path) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; node-&gt;x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; node-&gt;y &lt;&lt; <span class="hljs-string">&quot;) &quot;</span> &lt;&lt; endl;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>决策模块概述</title>
      <link href="/2024/08/03/%E5%86%B3%E7%AD%96%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/08/03/%E5%86%B3%E7%AD%96%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="输入输出">1 输入输出</h1><p>控制模块的目标是基于规划好的轨迹和当前车辆状态，输出控制指令给车辆，为自动驾驶车辆提供舒适的驾驶体验。</p><figure><img src="/images/resized_control_module.png" alt="Fig 1 控制模块"><figcaption>Fig 1 控制模块</figcaption></figure><ul><li>输入：规划好的轨迹（planning）和当前车辆状态(localization &amp;&amp; chassis)</li><li>输出：油门、刹车及方向盘转角(canbus)</li></ul><h1 id="车辆模型">2 车辆模型</h1><h2 id="自行车运动学模型">2.1 自行车运动学模型</h2><p>在自行车模型中，左右两个前轮由点 A 点的一个单轮表示。类似地，后轮由点 B 点的一个后轮表示。运动学模型中的主要假设是点 A 和 B 点的速度方向分别位于前轮和后轮的方向上。</p><p>假设：</p><ul><li>车辆的运动被限制在XY平面内，即没有考虑“上升”和“下降”运动。</li><li>左右轮转向运动相同，左右轮合成一个轮子。</li><li>忽略车轮的侧偏角，A点和B点的速度方向分别位于前轮和后轮的方向上。</li><li>忽略负载转移带来的质心位置变化。</li><li>车辆是刚性车身。</li></ul><figure><img src="/images/resized_Bicycle_KInematics.png" alt="Fig 2 自行车运动学模型"><figcaption>Fig 2 自行车运动学模型</figcaption></figure><h3 id="符号定义">符号定义</h3><ul><li><span class="math inline">\(C\)</span>：车辆质心</li><li><span class="math inline">\(\gamma = \psi + \beta\)</span>：航向角（质心速度方向与大地坐标系<span class="math inline">\(\vec{X}\)</span>轴的夹角）</li><li><span class="math inline">\(\beta\)</span>：侧偏角（质心速度方向和车身纵轴的夹角）</li><li><span class="math inline">\(\psi\)</span>：横摆角（车身轴线与大地坐标系<span class="math inline">\(\vec{X}\)</span>轴的夹角）</li><li><span class="math inline">\(\dot{\psi} = \frac{V}{R}\)</span>：低速情况下，假设<span class="math inline">\(R\)</span>变化缓慢</li></ul><p>这里假设相互作用的前后轮的侧偏角 <span class="math inline">\(\beta_f\)</span> 和 <span class="math inline">\(\beta_r\)</span> 都为0，对于车辆的低速运动（例如，速度小于5 m/s），这是一个合理的假设。在低速行驶时，轮胎产生的侧向力很小，两个轮胎的总侧向力是 <span class="math inline">\(\frac{mV^2}{R}\)</span>，此时前后轮的侧偏角可以近似为0（侧向力的大小与侧偏角近似成比例关系）。</p><h3 id="运动学方程">运动学方程</h3><p>AB点运动学模型的方程，可以得出：</p><p><span class="math display">\[\dot{X} = V \cos(\psi + \beta)\]</span></p><p><span class="math display">\[\dot{Y} = V \sin(\psi + \beta)\]</span></p><p><span class="math display">\[\dot{\psi} = \frac{V \cos(\beta)}{l_r + l_f} (\tan(\delta_f) - \tan(\delta_r))\]</span></p><h3 id="阿克曼转向车辆模型">阿克曼转向车辆模型</h3><p>实际应用时，一般会使用后轴中心的运动学模型（B点），即阿克曼转向车辆模型。</p><figure><img src="/images/resized_Ackerman_steering_model.png" alt="Fig 3 阿克曼转向车辆模型"><figcaption>Fig 3 阿克曼转向车辆模型</figcaption></figure><p>假定 <span class="math inline">\(\beta = 0\)</span>， <span class="math inline">\(\delta_r = 0\)</span>，<span class="math inline">\(\delta\)</span>为前轮转角，得：</p><p><span class="math display">\[\dot{X} = V \cos(\psi)\]</span></p><p><span class="math display">\[\dot{Y} = V \sin(\psi)\]</span></p><p><span class="math display">\[\dot{\psi} = \frac{V}{l_r} \tan(\delta_f)\]</span></p><h2 id="车辆二自由度动力学模型">2.2 车辆二自由度动力学模型</h2><p>在更高的车速下，不能再假设每个车轮的速度方向都在车轮的方向上，而是需要考虑轮胎的侧向力。轮胎的侧偏角定义为轮胎方向与车轮速度矢量方向之间的夹角。</p><figure><img src="/images/resized_slip_angle.png" alt="Fig 4 侧偏角"><figcaption>Fig 4 侧偏角</figcaption></figure><p>假设：</p><ul><li>车辆的运动被限制在XY平面内，即没有考虑“上升”和“下降”运动。</li><li>车轮的转向运动相同，车轮合成一个轮子。</li><li>车辆是刚性车身。</li><li>忽略负载转移带来的质心位置变化。</li><li>汽车纵向速度不变，即：<span class="math inline">\(V_y = C\)</span>。</li><li>忽略转向系统的影响，直接以前轮转角作为输入。</li><li>汽车横向加速度满足：<span class="math inline">\(a_y \leq 0.4g\)</span>，实验结果表明，对于小的侧偏角。此时轮胎侧偏力与侧偏角近似成正比。</li></ul><p>在上述假设下，汽车被简化为只有侧向和横摆两个自由度的两轮汽车模型。</p><figure><img src="/images/resized_Dynamic_Bicycle_Model.png" alt="Fig 5 车辆二自由度动力学模型"><figcaption>Fig 5 车辆二自由度动力学模型</figcaption></figure><p>由于质心侧偏角远小于车辆航向角和横摆角，在实际应用中可以认为航向角与横摆角相等,受力分析可以得到： <span class="math display">\[(F_{yf} \cos(\delta) - F_{xf} \sin(\delta)) + F_{yr} = m(\dot{v_y} + v_x \dot{\psi})\]</span></p><p><span class="math display">\[l_f (F_{yf} \cos(\delta) - F_{xf} \sin(\delta)) - l_r F_{yr} = I_z \ddot{\psi}\]</span> 这里横向加速度带有<span class="math inline">\(v_x\)</span>项，因为是矢量求导。</p><p>车辆的横向侧偏力可以写为</p><p><span class="math display">\[F_{yf} = 2 * c_f (\delta - \theta_{f}) \]</span></p><p><span class="math display">\[F_{yr} = 2 * c_r (-\theta_{r})\]</span></p><p><span class="math inline">\(c_f, c_r\)</span> 定义为侧偏刚度, 2 表示有两个轮子。</p><p>使用小角度假设， <span class="math display">\[\tan(\theta_{f}) = \frac{V_{yf} + l_{f}\dot{\psi}}{V_{x}}, \quad \tan(\theta_{r}) = \frac{V_{yr} - l_{r}\dot{\psi}}{V_{x}}\]</span></p><p><span class="math display">\[\theta_{f} = \frac{V_{yf} + l_{f}\dot{\psi}}{V_{x}}, \quad \theta_{r} = \frac{V_{yr} - l_{r}\dot{\psi}}{V_{x}}\]</span></p><p><span class="math display">\[\cos(\delta) \approx 1, \quad \sin(\delta) \approx 0\]</span></p><p>可以得到，</p><p><span class="math display">\[\begin{bmatrix}\dot{v}_y \\\ddot{\psi}\end{bmatrix}=\begin{bmatrix}-\frac{2c_f + 2c_r}{mv_x} &amp; \frac{2l_r c_r - 2l_f c_f}{mv_x} - v_x \\\frac{2l_r c_r - 2l_f c_f}{I_z v_x} &amp; -\frac{2l_f^2 c_f + 2l_r^2 c_r}{I_z v_x}\end{bmatrix}\begin{bmatrix}v_y \\\dot{\psi}\end{bmatrix}+\begin{bmatrix}\frac{2c_f}{m} \\\frac{2l_f c_f}{I_z}\end{bmatrix}\delta\]</span></p><p>定义误差：</p><p><span class="math display">\[\dot{\psi} = \frac{V_{x}}{R}\]</span></p><p><span class="math display">\[\ddot{e_{1}} = \ddot{y} + V_{x}\dot{\psi} - \frac{V_{x}^2}{R}\]</span></p><p><span class="math display">\[e_{2} = \psi - \psi_{des}\]</span></p><p>其中，<span class="math inline">\(e_1\)</span>为横向位置误差，<span class="math inline">\(e_2\)</span>为航向角误差。</p><p><span class="math display">\[\dot{x} = Ax + Bu + C\psi_{des}\]</span></p><p><span class="math display">\[X = \begin{bmatrix} e_1 &amp; e_2 &amp; \dot{e}_1 &amp; \dot{e}_2 \end{bmatrix}^T, \quad u = \delta\]</span></p><p><span class="math display">\[A = \begin{bmatrix}0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; -\frac{2c_f+2c_r}{mV_x} &amp; \frac{2c_f+2c_r}{m} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{mV_x} \\0 &amp; 0 &amp; 0 &amp; 1 \\0 &amp; \frac{2c_f\ell_f - 2c_r\ell_r}{I_zV_x} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{I_z} &amp; -\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix}\]</span></p><p><span class="math display">\[B = \begin{bmatrix}0 \\\frac{2c_f}{m} \\0 \\\frac{2c_f\ell_f}{I_z}\end{bmatrix} \delta, \quadC = \begin{bmatrix}0 \\\frac{-2c_f\ell_f + 2c_r\ell_r - V_x}{mV_x} \\0 \\-\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix}\]</span></p><p>综上，车辆二自由度动力学模型可以写为：</p><p><span class="math display">\[\frac{d}{dt} \begin{bmatrix}e_1 \\\dot{e}_1 \\e_2 \\\dot{e}_2\end{bmatrix} = \begin{bmatrix}0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; -\frac{2c_f+2c_r}{mV_x} &amp; \frac{2c_f+2c_r}{m} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{mV_x} \\0 &amp; 0 &amp; 0 &amp; 1 \\0 &amp; \frac{2c_f\ell_f - 2c_r\ell_r}{I_zV_x} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{I_z} &amp; -\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix}\begin{bmatrix}e_1 \\\dot{e}_1 \\e_2 \\\dot{e}_2\end{bmatrix}+\begin{bmatrix}0 \\\frac{2c_f}{m} \\0 \\\frac{2c_f\ell_f}{I_z}\end{bmatrix} \delta+\begin{bmatrix}0 \\\frac{-2c_f\ell_f + 2c_r\ell_r - V_x}{mV_x} \\0 \\-\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix} \dot{\psi}_{des}\]</span></p><h2 id="运动学和动力学参数标定">2.2 运动学和动力学参数标定</h2>]]></content>
      
      
      <categories>
          
          <category> 决策算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>规划算法串讲</title>
      <link href="/2024/08/02/%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E4%B8%B2%E8%AE%B2/"/>
      <url>/2024/08/02/%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E4%B8%B2%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="输入输出">1 输入输出</h1><p>控制模块的目标是基于规划好的轨迹和当前车辆状态，输出控制指令给车辆，为自动驾驶车辆提供舒适的驾驶体验。</p><figure><img src="/images/resized_control_module.png" alt="Fig 1 控制模块"><figcaption>Fig 1 控制模块</figcaption></figure><ul><li>输入：规划好的轨迹（planning）和当前车辆状态(localization &amp;&amp; chassis)</li><li>输出：油门、刹车及方向盘转角(canbus)</li></ul><h1 id="车辆模型">2 车辆模型</h1><h2 id="自行车运动学模型">2.1 自行车运动学模型</h2><p>在自行车模型中，左右两个前轮由点 A 点的一个单轮表示。类似地，后轮由点 B 点的一个后轮表示。运动学模型中的主要假设是点 A 和 B 点的速度方向分别位于前轮和后轮的方向上。</p><p>假设：</p><ul><li>车辆的运动被限制在XY平面内，即没有考虑“上升”和“下降”运动。</li><li>左右轮转向运动相同，左右轮合成一个轮子。</li><li>忽略车轮的侧偏角，A点和B点的速度方向分别位于前轮和后轮的方向上。</li><li>忽略负载转移带来的质心位置变化。</li><li>车辆是刚性车身。</li></ul><figure><img src="/images/resized_Bicycle_KInematics.png" alt="Fig 2 自行车运动学模型"><figcaption>Fig 2 自行车运动学模型</figcaption></figure><h3 id="符号定义">符号定义</h3><ul><li><span class="math inline">\(C\)</span>：车辆质心</li><li><span class="math inline">\(\gamma = \psi + \beta\)</span>：航向角（质心速度方向与大地坐标系<span class="math inline">\(\vec{X}\)</span>轴的夹角）</li><li><span class="math inline">\(\beta\)</span>：侧偏角（质心速度方向和车身纵轴的夹角）</li><li><span class="math inline">\(\psi\)</span>：横摆角（车身轴线与大地坐标系<span class="math inline">\(\vec{X}\)</span>轴的夹角）</li><li><span class="math inline">\(\dot{\psi} = \frac{V}{R}\)</span>：低速情况下，假设<span class="math inline">\(R\)</span>变化缓慢</li></ul><p>这里假设相互作用的前后轮的侧偏角 <span class="math inline">\(\beta_f\)</span> 和 <span class="math inline">\(\beta_r\)</span> 都为0，对于车辆的低速运动（例如，速度小于5 m/s），这是一个合理的假设。在低速行驶时，轮胎产生的侧向力很小，两个轮胎的总侧向力是 <span class="math inline">\(\frac{mV^2}{R}\)</span>，此时前后轮的侧偏角可以近似为0（侧向力的大小与侧偏角近似成比例关系）。</p><h3 id="运动学方程">运动学方程</h3><p>AB点运动学模型的方程，可以得出：</p><p><span class="math display">\[\dot{X} = V \cos(\psi + \beta)\]</span></p><p><span class="math display">\[\dot{Y} = V \sin(\psi + \beta)\]</span></p><p><span class="math display">\[\dot{\psi} = \frac{V \cos(\beta)}{l_r + l_f} (\tan(\delta_f) - \tan(\delta_r))\]</span></p><h3 id="阿克曼转向车辆模型">阿克曼转向车辆模型</h3><p>实际应用时，一般会使用后轴中心的运动学模型（B点），即阿克曼转向车辆模型。</p><figure><img src="/images/resized_Ackerman_steering_model.png" alt="Fig 3 阿克曼转向车辆模型"><figcaption>Fig 3 阿克曼转向车辆模型</figcaption></figure><p>假定 <span class="math inline">\(\beta = 0\)</span>， <span class="math inline">\(\delta_r = 0\)</span>，<span class="math inline">\(\delta\)</span>为前轮转角，得：</p><p><span class="math display">\[\dot{X} = V \cos(\psi)\]</span></p><p><span class="math display">\[\dot{Y} = V \sin(\psi)\]</span></p><p><span class="math display">\[\dot{\psi} = \frac{V}{l_r} \tan(\delta_f)\]</span></p><h2 id="车辆二自由度动力学模型">2.2 车辆二自由度动力学模型</h2><p>在更高的车速下，不能再假设每个车轮的速度方向都在车轮的方向上，而是需要考虑轮胎的侧向力。轮胎的侧偏角定义为轮胎方向与车轮速度矢量方向之间的夹角。</p><figure><img src="/images/resized_slip_angle.png" alt="Fig 4 侧偏角"><figcaption>Fig 4 侧偏角</figcaption></figure><p>假设：</p><ul><li>车辆的运动被限制在XY平面内，即没有考虑“上升”和“下降”运动。</li><li>车轮的转向运动相同，车轮合成一个轮子。</li><li>车辆是刚性车身。</li><li>忽略负载转移带来的质心位置变化。</li><li>汽车纵向速度不变，即：<span class="math inline">\(V_y = C\)</span>。</li><li>忽略转向系统的影响，直接以前轮转角作为输入。</li><li>汽车横向加速度满足：<span class="math inline">\(a_y \leq 0.4g\)</span>，实验结果表明，对于小的侧偏角。此时轮胎侧偏力与侧偏角近似成正比。</li></ul><p>在上述假设下，汽车被简化为只有侧向和横摆两个自由度的两轮汽车模型。</p><figure><img src="/images/resized_Dynamic_Bicycle_Model.png" alt="Fig 5 车辆二自由度动力学模型"><figcaption>Fig 5 车辆二自由度动力学模型</figcaption></figure><p>由于质心侧偏角远小于车辆航向角和横摆角，在实际应用中可以认为航向角与横摆角相等,受力分析可以得到： <span class="math display">\[(F_{yf} \cos(\delta) - F_{xf} \sin(\delta)) + F_{yr} = m(\dot{v_y} + v_x \dot{\psi})\]</span></p><p><span class="math display">\[l_f (F_{yf} \cos(\delta) - F_{xf} \sin(\delta)) - l_r F_{yr} = I_z \ddot{\psi}\]</span> 这里横向加速度带有<span class="math inline">\(v_x\)</span>项，因为是矢量求导。</p><p>车辆的横向侧偏力可以写为</p><p><span class="math display">\[F_{yf} = 2 * c_f (\delta - \theta_{f}) \]</span></p><p><span class="math display">\[F_{yr} = 2 * c_r (-\theta_{r})\]</span></p><p><span class="math inline">\(c_f, c_r\)</span> 定义为侧偏刚度, 2 表示有两个轮子。</p><p>使用小角度假设， <span class="math display">\[\tan(\theta_{f}) = \frac{V_{yf} + l_{f}\dot{\psi}}{V_{x}}, \quad \tan(\theta_{r}) = \frac{V_{yr} - l_{r}\dot{\psi}}{V_{x}}\]</span></p><p><span class="math display">\[\theta_{f} = \frac{V_{yf} + l_{f}\dot{\psi}}{V_{x}}, \quad \theta_{r} = \frac{V_{yr} - l_{r}\dot{\psi}}{V_{x}}\]</span></p><p><span class="math display">\[\cos(\delta) \approx 1, \quad \sin(\delta) \approx 0\]</span></p><p>可以得到，</p><p><span class="math display">\[\begin{bmatrix}\dot{v}_y \\\ddot{\psi}\end{bmatrix}=\begin{bmatrix}-\frac{2c_f + 2c_r}{mv_x} &amp; \frac{2l_r c_r - 2l_f c_f}{mv_x} - v_x \\\frac{2l_r c_r - 2l_f c_f}{I_z v_x} &amp; -\frac{2l_f^2 c_f + 2l_r^2 c_r}{I_z v_x}\end{bmatrix}\begin{bmatrix}v_y \\\dot{\psi}\end{bmatrix}+\begin{bmatrix}\frac{2c_f}{m} \\\frac{2l_f c_f}{I_z}\end{bmatrix}\delta\]</span></p><p>定义误差：</p><p><span class="math display">\[\dot{\psi} = \frac{V_{x}}{R}\]</span></p><p><span class="math display">\[\ddot{e_{1}} = \ddot{y} + V_{x}\dot{\psi} - \frac{V_{x}^2}{R}\]</span></p><p><span class="math display">\[e_{2} = \psi - \psi_{des}\]</span></p><p>其中，<span class="math inline">\(e_1\)</span>为横向位置误差，<span class="math inline">\(e_2\)</span>为航向角误差。</p><p><span class="math display">\[\dot{x} = Ax + Bu + C\psi_{des}\]</span></p><p><span class="math display">\[X = \begin{bmatrix} e_1 &amp; e_2 &amp; \dot{e}_1 &amp; \dot{e}_2 \end{bmatrix}^T, \quad u = \delta\]</span></p><p><span class="math display">\[A = \begin{bmatrix}0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; -\frac{2c_f+2c_r}{mV_x} &amp; \frac{2c_f+2c_r}{m} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{mV_x} \\0 &amp; 0 &amp; 0 &amp; 1 \\0 &amp; \frac{2c_f\ell_f - 2c_r\ell_r}{I_zV_x} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{I_z} &amp; -\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix}\]</span></p><p><span class="math display">\[B = \begin{bmatrix}0 \\\frac{2c_f}{m} \\0 \\\frac{2c_f\ell_f}{I_z}\end{bmatrix} \delta, \quadC = \begin{bmatrix}0 \\\frac{-2c_f\ell_f + 2c_r\ell_r - V_x}{mV_x} \\0 \\-\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix}\]</span></p><p>综上，车辆二自由度动力学模型可以写为：</p><p><span class="math display">\[\frac{d}{dt} \begin{bmatrix}e_1 \\\dot{e}_1 \\e_2 \\\dot{e}_2\end{bmatrix} = \begin{bmatrix}0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; -\frac{2c_f+2c_r}{mV_x} &amp; \frac{2c_f+2c_r}{m} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{mV_x} \\0 &amp; 0 &amp; 0 &amp; 1 \\0 &amp; \frac{2c_f\ell_f - 2c_r\ell_r}{I_zV_x} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{I_z} &amp; -\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix}\begin{bmatrix}e_1 \\\dot{e}_1 \\e_2 \\\dot{e}_2\end{bmatrix}+\begin{bmatrix}0 \\\frac{2c_f}{m} \\0 \\\frac{2c_f\ell_f}{I_z}\end{bmatrix} \delta+\begin{bmatrix}0 \\\frac{-2c_f\ell_f + 2c_r\ell_r - V_x}{mV_x} \\0 \\-\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix} \dot{\psi}_{des}\]</span></p><h2 id="运动学和动力学参数标定">2.2 运动学和动力学参数标定</h2>]]></content>
      
      
      <categories>
          
          <category> 规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>控制基本原理</title>
      <link href="/2024/08/01/%E6%8E%A7%E5%88%B6%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2024/08/01/%E6%8E%A7%E5%88%B6%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="输入输出">1 输入输出</h1><p>控制模块的目标是基于规划好的轨迹和当前车辆状态，输出控制指令给车辆，为自动驾驶车辆提供舒适的驾驶体验。</p><p><img src="/images/resized_control_module.png" alt="Fig 1 控制模块" style="width:60%;height:auto;"></p><ul><li>输入：规划好的轨迹（planning）和当前车辆状态(localization &amp;&amp; chassis)</li><li>输出：油门、刹车及方向盘转角(canbus)</li></ul><h1 id="车辆模型">2 车辆模型</h1><h2 id="自行车运动学模型">2.1 自行车运动学模型</h2><p>在自行车模型中，左右两个前轮由点 A 点的一个单轮表示。类似地，后轮由点 B 点的一个后轮表示。运动学模型中的主要假设是点 A 和 B 点的速度方向分别位于前轮和后轮的方向上。</p><p>假设：</p><ul><li>车辆的运动被限制在XY平面内，即没有考虑“上升”和“下降”运动。</li><li>左右轮转向运动相同，左右轮合成一个轮子。</li><li>忽略车轮的侧偏角，A点和B点的速度方向分别位于前轮和后轮的方向上。</li><li>忽略负载转移带来的质心位置变化。</li><li>车辆是刚性车身。</li></ul><p><img src="/images/resized_Bicycle_KInematics.png" alt="Fig 2 自行车运动学模型" style="width:60%;height:auto;"></p><h3 id="符号定义">符号定义</h3><ul><li><span class="math inline">\(C\)</span>：车辆质心</li><li><span class="math inline">\(\gamma = \psi + \beta\)</span>：航向角（质心速度方向与大地坐标系<span class="math inline">\(\vec{X}\)</span>轴的夹角）</li><li><span class="math inline">\(\beta\)</span>：侧偏角（质心速度方向和车身纵轴的夹角）</li><li><span class="math inline">\(\psi\)</span>：横摆角（车身轴线与大地坐标系<span class="math inline">\(\vec{X}\)</span>轴的夹角）</li><li><span class="math inline">\(\dot{\psi} = \frac{V}{R}\)</span>：低速情况下，假设<span class="math inline">\(R\)</span>变化缓慢</li></ul><p>这里假设相互作用的前后轮的侧偏角 <span class="math inline">\(\beta_f\)</span> 和 <span class="math inline">\(\beta_r\)</span> 都为0，对于车辆的低速运动（例如，速度小于5 m/s），这是一个合理的假设。在低速行驶时，轮胎产生的侧向力很小，两个轮胎的总侧向力是 <span class="math inline">\(\frac{mV^2}{R}\)</span>，此时前后轮的侧偏角可以近似为0（侧向力的大小与侧偏角近似成比例关系）。</p><h3 id="运动学方程">运动学方程</h3><p>AB点运动学模型的方程，可以得出：</p><p><span class="math display">\[\dot{X} = V \cos(\psi + \beta)\]</span></p><p><span class="math display">\[\dot{Y} = V \sin(\psi + \beta)\]</span></p><p><span class="math display">\[\dot{\psi} = \frac{V \cos(\beta)}{l_r + l_f} (\tan(\delta_f) - \tan(\delta_r))\]</span></p><h3 id="阿克曼转向车辆模型">阿克曼转向车辆模型</h3><p>实际应用时，一般会使用后轴中心的运动学模型（B点），即阿克曼转向车辆模型。</p><p><img src="/images/resized_Ackerman_steering_model.png" alt="Fig 3 阿克曼转向车辆模型" style="width:60%;height:auto;"></p><p>假定 <span class="math inline">\(\beta = 0\)</span>， <span class="math inline">\(\delta_r = 0\)</span>，<span class="math inline">\(\delta\)</span>为前轮转角，得：</p><p><span class="math display">\[\dot{X} = V \cos(\psi)\]</span></p><p><span class="math display">\[\dot{Y} = V \sin(\psi)\]</span></p><p><span class="math display">\[\dot{\psi} = \frac{V}{L} \tan(\delta_f)\]</span></p><h2 id="车辆二自由度动力学模型">2.2 车辆二自由度动力学模型</h2><p>在更高的车速下，不能再假设每个车轮的速度方向都在车轮的方向上，而是需要考虑轮胎的侧向力。轮胎的侧偏角定义为轮胎方向与车轮速度矢量方向之间的夹角。</p><p><img src="/images/resized_slip_angle.png" alt="Fig 4 侧偏角" style="width:60%;height:auto;"></p><p>假设：</p><ul><li>车辆的运动被限制在XY平面内，即没有考虑“上升”和“下降”运动。</li><li>车轮的转向运动相同，车轮合成一个轮子。</li><li>车辆是刚性车身。</li><li>忽略负载转移带来的质心位置变化。</li><li>汽车纵向速度不变，即：<span class="math inline">\(V_y = C\)</span>。</li><li>忽略转向系统的影响，直接以前轮转角作为输入。</li><li>汽车横向加速度满足：<span class="math inline">\(a_y \leq 0.4g\)</span>，实验结果表明，对于小的侧偏角。此时轮胎侧偏力与侧偏角近似成正比。</li></ul><p>在上述假设下，汽车被简化为只有侧向和横摆两个自由度的两轮汽车模型。</p><p><img src="/images/resized_Dynamic_Bicycle_Model.png" alt="Fig 5 车辆二自由度动力学模型" style="width:60%;height:auto;"></p><p>由于质心侧偏角远小于车辆航向角和横摆角，在实际应用中可以认为航向角与横摆角相等,受力分析可以得到： <span class="math display">\[(F_{yf} \cos(\delta) - F_{xf} \sin(\delta)) + F_{yr} = m(\dot{v_y} + v_x \dot{\psi})\]</span></p><p><span class="math display">\[l_f (F_{yf} \cos(\delta) - F_{xf} \sin(\delta)) - l_r F_{yr} = I_z \ddot{\psi}\]</span> 这里横向加速度带有<span class="math inline">\(v_x\)</span>项，因为是矢量求导。</p><p>车辆的横向侧偏力可以写为</p><p><span class="math display">\[F_{yf} = 2 * c_f (\delta - \theta_{f}) \]</span></p><p><span class="math display">\[F_{yr} = 2 * c_r (-\theta_{r})\]</span></p><p><span class="math inline">\(c_f, c_r\)</span> 定义为侧偏刚度, 2 表示有两个轮子。</p><p>使用小角度假设， <span class="math display">\[\tan(\theta_{f}) = \frac{V_{yf} + l_{f}\dot{\psi}}{V_{x}}, \quad \tan(\theta_{r}) = \frac{V_{yr} - l_{r}\dot{\psi}}{V_{x}}\]</span></p><p><span class="math display">\[\theta_{f} = \frac{V_{yf} + l_{f}\dot{\psi}}{V_{x}}, \quad \theta_{r} = \frac{V_{yr} - l_{r}\dot{\psi}}{V_{x}}\]</span></p><p><span class="math display">\[\cos(\delta) \approx 1, \quad \sin(\delta) \approx 0\]</span></p><p>可以得到，</p><p><span class="math display">\[\begin{bmatrix}\dot{v}_y \\\ddot{\psi}\end{bmatrix}=\begin{bmatrix}-\frac{2c_f + 2c_r}{mv_x} &amp; \frac{2l_r c_r - 2l_f c_f}{mv_x} - v_x \\\frac{2l_r c_r - 2l_f c_f}{I_z v_x} &amp; -\frac{2l_f^2 c_f + 2l_r^2 c_r}{I_z v_x}\end{bmatrix}\begin{bmatrix}v_y \\\dot{\psi}\end{bmatrix}+\begin{bmatrix}\frac{2c_f}{m} \\\frac{2l_f c_f}{I_z}\end{bmatrix}\delta\]</span></p><p>定义误差：</p><p><span class="math display">\[\dot{\psi} = \frac{V_{x}}{R}\]</span></p><p><span class="math display">\[\ddot{e_{1}} = \ddot{y} + V_{x}\dot{\psi} - \frac{V_{x}^2}{R}\]</span></p><p><span class="math display">\[e_{2} = \psi - \psi_{des}\]</span></p><p>其中，<span class="math inline">\(e_1\)</span>为横向位置误差，<span class="math inline">\(e_2\)</span>为航向角误差。</p><p><span class="math display">\[\dot{x} = Ax + Bu + C\psi_{des}\]</span></p><p><span class="math display">\[X = \begin{bmatrix} e_1 &amp; e_2 &amp; \dot{e}_1 &amp; \dot{e}_2 \end{bmatrix}^T, \quad u = \delta\]</span></p><p><span class="math display">\[A = \begin{bmatrix}0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; -\frac{2c_f+2c_r}{mV_x} &amp; \frac{2c_f+2c_r}{m} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{mV_x} \\0 &amp; 0 &amp; 0 &amp; 1 \\0 &amp; \frac{2c_f\ell_f - 2c_r\ell_r}{I_zV_x} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{I_z} &amp; -\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix}\]</span></p><p><span class="math display">\[B = \begin{bmatrix}0 \\\frac{2c_f}{m} \\0 \\\frac{2c_f\ell_f}{I_z}\end{bmatrix} \delta, \quadC = \begin{bmatrix}0 \\\frac{-2c_f\ell_f + 2c_r\ell_r - V_x}{mV_x} \\0 \\-\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix}\]</span></p><p>综上，车辆二自由度动力学模型可以写为：</p><p><span class="math display">\[\frac{d}{dt} \begin{bmatrix}e_1 \\\dot{e}_1 \\e_2 \\\dot{e}_2\end{bmatrix} = \begin{bmatrix}0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; -\frac{2c_f+2c_r}{mV_x} &amp; \frac{2c_f+2c_r}{m} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{mV_x} \\0 &amp; 0 &amp; 0 &amp; 1 \\0 &amp; \frac{2c_f\ell_f - 2c_r\ell_r}{I_zV_x} &amp; -\frac{2c_f\ell_f - 2c_r\ell_r}{I_z} &amp; -\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix}\begin{bmatrix}e_1 \\\dot{e}_1 \\e_2 \\\dot{e}_2\end{bmatrix}+\begin{bmatrix}0 \\\frac{2c_f}{m} \\0 \\\frac{2c_f\ell_f}{I_z}\end{bmatrix} \delta+\begin{bmatrix}0 \\\frac{-2c_f\ell_f + 2c_r\ell_r - V_x}{mV_x} \\0 \\-\frac{2c_f\ell_f^2 + 2c_r\ell_r^2}{I_zV_x}\end{bmatrix} \dot{\psi}_{des}\]</span></p><h2 id="运动学和动力学参数标定">2.2 运动学和动力学参数标定</h2>]]></content>
      
      
      <categories>
          
          <category> 控制算法 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
