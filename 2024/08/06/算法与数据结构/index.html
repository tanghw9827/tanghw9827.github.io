<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png"><link rel="icon" href="/img/avatar.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Harvey Tang"><meta name="keywords" content="C++, Autopilot, Planning, Control"><meta name="description" content="在本篇文章中，将首先介绍数据结构，包括数组与链表、栈与队列、哈希表、树、堆以及图，然后介绍常用的算法，包括搜索、排序、分治、回溯、动态规划及贪心算法。"><meta property="og:type" content="article"><meta property="og:title" content="算法与数据结构"><meta property="og:url" content="https://tanghw9827.github.io/2024/08/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html"><meta property="og:site_name" content="Harvey"><meta property="og:description" content="在本篇文章中，将首先介绍数据结构，包括数组与链表、栈与队列、哈希表、树、堆以及图，然后介绍常用的算法，包括搜索、排序、分治、回溯、动态规划及贪心算法。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tanghw9827.github.io/img/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"><meta property="article:published_time" content="2024-08-05T16:00:00.000Z"><meta property="article:modified_time" content="2024-08-08T12:32:40.958Z"><meta property="article:author" content="Harvey Tang"><meta property="article:tag" content="C++, Autopilot, Planning, Control"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://tanghw9827.github.io/img/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"><title>算法与数据结构 - Harvey</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"tanghw9827.github.io",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Harvey Tang</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="算法与数据结构"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-08-06 00:00" pubdate>2024年8月6日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 7.2k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 60 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header"><img src="/img/default.png" srcset="/img/loading.gif" lazyload alt="Post Image" style="width:20px;height:20px;margin-right:10px"> 算法与数据结构</h1><div class="markdown-body"><meta name="referrer" content="no-referrer"><h1 id="图论">1 图论</h1><h2 id="图的定义">1.1 图的定义</h2><p><u>图（graph）</u>是一种非线性数据结构，由<u>顶点（vertex）</u>和<u>边（edge）</u>组成。我们可以将图 <span class="math inline">\(G\)</span> 抽象地表示为一组顶点 <span class="math inline">\(V\)</span> 和一组边 <span class="math inline">\(E\)</span> 的集合。以下示例展示了一个包含 5 个顶点和 7 条边的图。</p><p><span class="math display">\[ \begin{aligned} V &amp; = \{ 1, 2, 3, 4, 5 \} \newline E &amp; = \{ (1,2), (1,3), (1,5), (2,3), (2,4), (2,5), (4,5) \} \newline G &amp; = \{ V, E \} \newline \end{aligned} \]</span></p><p>如果将顶点看作节点，将边看作连接各个节点的引用（指针），我们就可以将图看作一种从链表拓展而来的数据结构。如下图所示，<strong>相较于线性关系（链表）和分治关系（树），网络关系（图）的自由度更高</strong>，因而更为复杂。</p><figure><img src="https://github.com/krahets/hello-algo/raw/main/docs/chapter_graph/graph.assets/linkedlist_tree_graph.png" srcset="/img/loading.gif" lazyload alt="链表、树、图之间的关系"><figcaption>链表、树、图之间的关系</figcaption></figure><h2 id="图的表示">1.2 图的表示</h2><p>图的常用表示方式包括“邻接矩阵”和“邻接表”。以下使用无向图进行举例。</p><h3 id="邻接矩阵">邻接矩阵</h3><p>设图的顶点数量为 <span class="math inline">\(n\)</span> ，<u>邻接矩阵（adjacency matrix）</u>使用一个 <span class="math inline">\(n \times n\)</span> 大小的矩阵来表示图，每一行（列）代表一个顶点，矩阵元素代表边，用 <span class="math inline">\(1\)</span> 或 <span class="math inline">\(0\)</span> 表示两个顶点之间是否存在边。</p><p>如下图所示，设邻接矩阵为 <span class="math inline">\(M\)</span>、顶点列表为 <span class="math inline">\(V\)</span> ，那么矩阵元素 <span class="math inline">\(M[i, j] = 1\)</span> 表示顶点 <span class="math inline">\(V[i]\)</span> 到顶点 <span class="math inline">\(V[j]\)</span> 之间存在边，反之 <span class="math inline">\(M[i, j] = 0\)</span> 表示两顶点之间无边。</p><figure><img src="https://github.com/krahets/hello-algo/raw/main/docs/chapter_graph/graph.assets/adjacency_matrix.png" srcset="/img/loading.gif" lazyload alt="图的邻接矩阵表示"><figcaption>图的邻接矩阵表示</figcaption></figure><p>邻接矩阵具有以下特性。</p><ul><li>顶点不能与自身相连，因此邻接矩阵主对角线元素没有意义。</li><li>对于无向图，两个方向的边等价，此时邻接矩阵关于主对角线对称。</li><li>将邻接矩阵的元素从 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(0\)</span> 替换为权重，则可表示有权图。</li></ul><p>使用邻接矩阵表示图时，我们可以直接访问矩阵元素以获取边，因此增删查改操作的效率很高，时间复杂度均为 <span class="math inline">\(O(1)\)</span> 。然而，矩阵的空间复杂度为 <span class="math inline">\(O(n^2)\)</span> ，内存占用较多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">createAdjMatrix</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">const</span> vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&amp; edges) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adjMatrix</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; edge : edges) &#123;<br>            adjMatrix[edge.first][edge.second] = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 如果是无向图，取消注释下一行</span><br>            <span class="hljs-comment">// adjMatrix[edge.second][edge.first] = 1;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> adjMatrix;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printAdjMatrix</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; adjMatrix)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; row : adjMatrix) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : row) &#123;<br>                cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>            cout &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Solution solution;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">edges</span>(m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        cin &gt;&gt; edges[i].first &gt;&gt; edges[i].second;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adjMatrix = solution.<span class="hljs-built_in">createAdjMatrix</span>(n, edges);<br>    solution.<span class="hljs-built_in">printAdjMatrix</span>(adjMatrix);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p></p><h3 id="邻接表">邻接表</h3><p><u>邻接表（adjacency list）</u>使用 <span class="math inline">\(n\)</span> 个链表来表示图，链表节点表示顶点。第 <span class="math inline">\(i\)</span> 个链表对应顶点 <span class="math inline">\(i\)</span> ，其中存储了该顶点的所有邻接顶点（与该顶点相连的顶点）。下图展示了一个使用邻接表存储的图的示例。</p><figure><img src="https://github.com/krahets/hello-algo/raw/main/docs/chapter_graph/graph.assets/adjacency_list.png" srcset="/img/loading.gif" lazyload alt="图的邻接表表示"><figcaption>图的邻接表表示</figcaption></figure><p>邻接表仅存储实际存在的边，而边的总数通常远小于 <span class="math inline">\(n^2\)</span> ，因此它更加节省空间。然而，在邻接表中需要通过遍历链表来查找边，因此其时间效率不如邻接矩阵。</p><p>观察上图，<strong>邻接表结构与哈希表中的“链式地址”非常相似，因此我们也可以采用类似的方法来优化效率</strong>。比如当链表较长时，可以将链表转化为 AVL 树或红黑树，从而将时间效率从 <span class="math inline">\(O(n)\)</span> 优化至 <span class="math inline">\(O(\log n)\)</span> ；还可以把链表转换为哈希表，从而将时间复杂度降至 <span class="math inline">\(O(1)\)</span> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">createAdjList</span>(<span class="hljs-type">const</span> vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&amp; edges) &#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; adjList;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; edge : edges) &#123;<br>            adjList[edge.first].<span class="hljs-built_in">push_back</span>(edge.second);<br>            <span class="hljs-comment">// 如果是无向图，取消注释下一行</span><br>            <span class="hljs-comment">// adjList[edge.second].push_back(edge.first);</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> adjList;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printAdjList</span><span class="hljs-params">(<span class="hljs-type">const</span> unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; adjList)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; node : adjList) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Node &quot;</span> &lt;&lt; node.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : node.second) &#123;<br>                cout &lt;&lt; neighbor &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>            cout &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Solution solution;<br>    <span class="hljs-type">int</span> m;<br>    cin &gt;&gt; m;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">edges</span>(m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        cin &gt;&gt; edges[i].first &gt;&gt; edges[i].second;<br>    &#125;<br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; adjList = solution.<span class="hljs-built_in">createAdjList</span>(edges);<br>    solution.<span class="hljs-built_in">printAdjList</span>(adjList);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图的操作">1.3 图的操作</h2><ul><li>初始化</li><li>添加边，删除边</li><li>添加顶点，删除顶点<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-comment">/* 添加顶点 */</span><br><span class="hljs-type">void</span> addVertex(<span class="hljs-type">int</span> val) &#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 向顶点列表中添加新顶点的值</span><br>    vertices.push_back(val);<br>    <span class="hljs-comment">// 在邻接矩阵中添加一行</span><br>    adjMat.emplace_back(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>    <span class="hljs-comment">// 在邻接矩阵中添加一列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; &amp;<span class="hljs-built_in">row</span> : adjMat) &#123;<br>        <span class="hljs-built_in">row</span>.push_back(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 删除顶点 */</span><br><span class="hljs-type">void</span> removeVertex(<span class="hljs-type">int</span> index) &#123;<br>    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-built_in">size</span>()) &#123;<br>        throw out_of_range(<span class="hljs-string">&quot;顶点不存在&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 在顶点列表中移除索引 index 的顶点</span><br>    vertices.erase(vertices.begin() + index);<br>    <span class="hljs-comment">// 在邻接矩阵中删除索引 index 的行</span><br>    adjMat.erase(adjMat.begin() + index);<br>    <span class="hljs-comment">// 在邻接矩阵中删除索引 index 的列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; &amp;<span class="hljs-built_in">row</span> : adjMat) &#123;<br>        <span class="hljs-built_in">row</span>.erase(<span class="hljs-built_in">row</span>.begin() + index);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 添加边 */</span><br><span class="hljs-comment">// 参数 i, j 对应 vertices 元素索引</span><br><span class="hljs-type">void</span> addEdge(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123;<br>    <span class="hljs-comment">// 索引越界与相等处理</span><br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= <span class="hljs-built_in">size</span>() || j &gt;= <span class="hljs-built_in">size</span>() || i == j) &#123;<br>        throw out_of_range(<span class="hljs-string">&quot;顶点不存在&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 在无向图中，邻接矩阵关于主对角线对称，即满足 (i, j) == (j, i)</span><br>    adjMat[i][j] = <span class="hljs-number">1</span>;<br>    adjMat[j][i] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/* 删除边 */</span><br><span class="hljs-comment">// 参数 i, j 对应 vertices 元素索引</span><br><span class="hljs-type">void</span> removeEdge(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123;<br>    <span class="hljs-comment">// 索引越界与相等处理</span><br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= <span class="hljs-built_in">size</span>() || j &gt;= <span class="hljs-built_in">size</span>() || i == j) &#123;<br>        throw out_of_range(<span class="hljs-string">&quot;顶点不存在&quot;</span>);<br>    &#125;<br>    adjMat[i][j] = <span class="hljs-number">0</span>;<br>    adjMat[j][i] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="图的遍历">1.4 图的遍历</h2><h3 id="bfs广度优先搜索">BFS(广度优先搜索)</h3><p><strong>广度优先遍历是一种由近及远的遍历方式，从某个节点出发，始终优先访问距离最近的顶点，并一层层向外扩张</strong>。如下图所示，从左上角顶点出发，首先遍历该顶点的所有邻接顶点，然后遍历下一个顶点的所有邻接顶点，以此类推，直至所有顶点访问完毕。</p><figure><img src="https://github.com/krahets/hello-algo/raw/main/docs//chapter_graph/graph_traversal.assets/graph_bfs.png" srcset="/img/loading.gif" lazyload alt="图的广度优先遍历"><figcaption>图的广度优先遍历</figcaption></figure><ul><li>算法模板<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 节点结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> x; <span class="hljs-comment">// 节点的索引</span><br>    shared_ptr&lt;Node&gt; parent; <span class="hljs-comment">// 父节点指针</span><br><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> x, shared_ptr&lt;Node&gt; parent = <span class="hljs-literal">nullptr</span>) <br>        : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">parent</span>(parent) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 检查节点是否合法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidNode</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> grid[x][v] == <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// BFS算法实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, vector&lt;shared_ptr&lt;Node&gt;&gt;&amp; path, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// openList普通队列</span><br>    queue&lt;shared_ptr&lt;Node&gt;&gt; openList;<br>    <span class="hljs-comment">// closedList数组，记录已访问节点</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">closedList</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br><br>    <span class="hljs-comment">// 初始化起始节点</span><br>    shared_ptr&lt;Node&gt; startNode = <span class="hljs-built_in">make_shared</span>&lt;Node&gt;(start);<br>    openList.<span class="hljs-built_in">push</span>(startNode);<br><br>    <span class="hljs-comment">// BFS算法主循环</span><br>    <span class="hljs-keyword">while</span> (!openList.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// 获取队列中的第一个节点</span><br>        shared_ptr&lt;Node&gt; current = openList.<span class="hljs-built_in">front</span>();<br>        openList.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-comment">// 如果当前节点是目标节点，构建路径并返回</span><br>        <span class="hljs-keyword">if</span> (current-&gt;x == end) &#123;<br>            <span class="hljs-keyword">while</span> (current) &#123;<br>                path.<span class="hljs-built_in">push_back</span>(current);<br>                current = current-&gt;parent;<br>            &#125;<br>            <span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 将当前节点标记为已访问</span><br>        closedList[current-&gt;x] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 获取当前节点的所有nextNode</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; v++) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isValidNode</span>(current-&gt;x, v, grid) || closedList[v]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            shared_ptr&lt;Node&gt; newNode = <span class="hljs-built_in">make_shared</span>&lt;Node&gt;(v, current); <span class="hljs-comment">// 创建新节点</span><br>            openList.<span class="hljs-built_in">push</span>(newNode); <span class="hljs-comment">// 将新节点加入队列</span><br>            closedList[v] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记新节点为已访问</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, p1, p2;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        cin &gt;&gt; p1 &gt;&gt; p2;<br>        grid[p1][p2] = <span class="hljs-number">1</span>;<br>        grid[p2][p1] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 无向图</span><br>    &#125;<br><br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> end = n;<br>    vector&lt;shared_ptr&lt;Node&gt;&gt; path;<br><br>    <span class="hljs-built_in">bfs</span>(grid, start, end, path, n);<br><br>    <span class="hljs-comment">// 打印路径长度</span><br>    <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">empty</span>()) &#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &lt;&lt; endl; <span class="hljs-comment">// 因为路径长度是节点数-1</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="dfs深度优先搜索">DFS(深度优先搜索)</h3><p><strong>深度优先遍历是一种优先走到底、无路可走再回头的遍历方式</strong>。如下图所示，从左上角顶点出发，访问当前顶点的某个邻接顶点，直到走到尽头时返回，再继续走到尽头并返回，以此类推，直至所有顶点遍历完成。</p><figure><img src="https://github.com/krahets/hello-algo/raw/main/docs//chapter_graph/graph_traversal.assets/graph_dfs.png" srcset="/img/loading.gif" lazyload alt="图的深度优先遍历"><figcaption>图的深度优先遍历</figcaption></figure><h2 id="图的遍历基本题型">1.5 图的遍历基本题型</h2><ul><li>有向图的完全可达性</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(visited[x])&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    visited[x] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (graph.<span class="hljs-built_in">find</span>(x) != graph.<span class="hljs-built_in">end</span>())&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i : graph.<span class="hljs-built_in">at</span>(x))&#123;<br>            <span class="hljs-built_in">dfs</span>(graph, i, visited);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; graph;<br>    <span class="hljs-type">int</span> s, t;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        graph[s].<span class="hljs-built_in">push_back</span>(t);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n<span class="hljs-number">+1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">1</span>, visited);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!visited[i])&#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>所有可达路径</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; n, <span class="hljs-type">int</span> x, vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; result)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x == n) &#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (graph.<span class="hljs-built_in">find</span>(x) != graph.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i : graph.<span class="hljs-built_in">at</span>(x) &#123;  <span class="hljs-comment">//使用[x]的话当键不存在，将抛出异常而而插入默认值修改graph</span><br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">dfs</span>(graph, n, i, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-built_in">main</span>() &#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; graph;<br>    <span class="hljs-type">int</span> s, t;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        graph[s].<span class="hljs-built_in">push_back</span>(t);<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dfs</span>(graph, n, <span class="hljs-number">1</span>, path, result);<br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; path : result) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>                cout &lt;&lt; path[i] &lt;&lt; endl;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cout &lt;&lt; path[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p></p></li><li>岛屿数量（DFS）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 节点结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> x, y; <span class="hljs-comment">// 节点的坐标</span><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 检查节点是否合法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidNode</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; grid.<span class="hljs-built_in">size</span>() &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; grid[x][y] == <span class="hljs-number">1</span> &amp;&amp; !visited[x][y]);<br>&#125;<br><br><span class="hljs-comment">// 使用BFS标记所有相连的1为已访问</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> startX, <span class="hljs-type">int</span> startY)</span> </span>&#123;<br>    <span class="hljs-comment">// 定义四个方向的移动</span><br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; directions = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    queue&lt;shared_ptr&lt;Node&gt;&gt; openList;<br>    openList.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;Node&gt;(startX, startY));<br>    visited[startX][startY] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// BFS算法主循环</span><br>    <span class="hljs-keyword">while</span> (!openList.<span class="hljs-built_in">empty</span>()) &#123;<br>        shared_ptr&lt;Node&gt; current = openList.<span class="hljs-built_in">front</span>();<br>        openList.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; dir : directions) &#123;<br>            <span class="hljs-type">int</span> newX = current-&gt;x + dir.first;<br>            <span class="hljs-type">int</span> newY = current-&gt;y + dir.second;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValidNode</span>(newX, newY, grid, visited)) &#123;<br>                visited[newX][newY] = <span class="hljs-literal">true</span>;<br>                openList.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;Node&gt;(newX, newY));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (grid.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> numIslands = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> rows = grid.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> cols = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(rows, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(cols, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[i][j]) &#123;<br>                <span class="hljs-built_in">bfs</span>(grid, visited, i, j);<br>                ++numIslands;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> numIslands;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            cin &gt;&gt; grid[i][j];<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-built_in">numIslands</span>(grid) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>岛屿数量（DFS）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 节点结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> x, y; <span class="hljs-comment">// 节点的坐标</span><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 检查节点是否合法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidNode</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; grid.<span class="hljs-built_in">size</span>() &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; grid[x][y] == <span class="hljs-number">1</span> &amp;&amp; !visited[x][y]);<br>&#125;<br><br><span class="hljs-comment">// 使用DFS标记所有相连的1为已访问</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> startX, <span class="hljs-type">int</span> startY)</span> </span>&#123;<br>    <span class="hljs-comment">// 定义四个方向的移动</span><br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; directions = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    visited[startX][startY] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; dir : directions) &#123;<br>        <span class="hljs-type">int</span> newX = startX + dir.first;<br>        <span class="hljs-type">int</span> newY = startY + dir.second;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValidNode</span>(newX, newY, grid, visited)) &#123;<br>            <span class="hljs-built_in">dfs</span>(grid, visited, newX, newY);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (grid.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> numIslands = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> rows = grid.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> cols = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(rows, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(cols, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[i][j]) &#123;<br>                <span class="hljs-built_in">dfs</span>(grid, visited, i, j);<br>                ++numIslands;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> numIslands;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            cin &gt;&gt; grid[i][j];<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-built_in">numIslands</span>(grid) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>沉没孤岛（BFS）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> mark)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (visited[i][j] || graph[i][j] == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    visited[i][j] = mark; <br>    <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) <span class="hljs-built_in">dfs</span>(graph, visited, i - <span class="hljs-number">1</span>, j, mark);<br>    <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; graph[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">dfs</span>(graph, visited, i, j + <span class="hljs-number">1</span>, mark);<br>    <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; graph.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">dfs</span>(graph, visited, i + <span class="hljs-number">1</span>, j, mark);<br>    <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) <span class="hljs-built_in">dfs</span>(graph, visited, i, j - <span class="hljs-number">1</span>, mark);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            cin &gt;&gt; graph[i][j]; <br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[i][<span class="hljs-number">0</span>] &amp;&amp; graph[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(graph, visited, i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!visited[i][m<span class="hljs-number">-1</span>] &amp;&amp; graph[i][m<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(graph, visited, i, m<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[<span class="hljs-number">0</span>][j] &amp;&amp; graph[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(graph, visited, <span class="hljs-number">0</span>, j, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!visited[n<span class="hljs-number">-1</span>][j] &amp;&amp; graph[n<span class="hljs-number">-1</span>][j] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(graph, visited, n<span class="hljs-number">-1</span>, j, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; graph[i][j] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">dfs</span>(graph, visited, i, j, <span class="hljs-number">2</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (visited[i][j] == <span class="hljs-number">2</span>) &#123;<br>                graph[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            cout &lt;&lt; graph[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>其余岛屿问题（岛屿的最大面积、孤岛的总面积、建造最大工岛、字符串接龙、岛屿的周长）</p></li></ul><h2 id="并查集">1.6 并查集</h2><p>并查集常用来解决连通性问题，当我们需要判断两个元素是否在同一个集合里的时候，可以使用并查集。 并查集主要有两个功能：</p><ul><li>将两个元素添加到一个集合中。</li><li>判断两个元素在不在同一个集合<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (n, <span class="hljs-number">0</span>); <span class="hljs-comment">// C++里的一种数组结构</span><br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 路径压缩</span><br>&#125;<br><br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="并查集基本题型">1.7 并查集基本题型</h2><ul><li>寻找存在的路径<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">father</span><span class="hljs-params">(<span class="hljs-number">1001</span>,<span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">if</span>(u == v) <span class="hljs-keyword">return</span>;<br>    father[u] = v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> m;<br>    cin &gt;&gt; m;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">int</span> s, t;<br>    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; last_edge;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-built_in">join</span>(s, t);<br>    &#125;<br>    cin &gt;&gt; s &gt;&gt; t;<br>    cout &lt;&lt; <span class="hljs-built_in">isSame</span>(s, t) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>冗余连接<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">father</span><span class="hljs-params">(<span class="hljs-number">1001</span>,<span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">if</span>(u == v) <span class="hljs-keyword">return</span>;<br>    father[u] = v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">int</span> s, t;<br>    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; last_edge;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isSame</span>(s, t))&#123;<br>            last_edge = &#123;s, t&#125;;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">join</span>(s, t);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; last_edge.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; last_edge.second &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>其余并查集问题（冗余连接II）</li></ul><h2 id="最小生成树">1.8 最小生成树</h2><ul><li>Prim算法<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> e, v; <span class="hljs-comment">// e是节点数，v是边数</span><br>    cin &gt;&gt; e &gt;&gt; v;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(e<span class="hljs-number">+1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(e<span class="hljs-number">+1</span>, INT_MAX));<br>    <br>    <span class="hljs-comment">// 读取边的输入，v1和v2是两个节点，val是它们之间的边的权重</span><br>    <span class="hljs-type">int</span> v1, v2, val;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v; i++) &#123;<br>        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;<br>        grid[v1][v2] = val;<br>        grid[v2][v1] = val;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 用于记录每个节点是否已经在生成树中</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">isTree</span><span class="hljs-params">(e<span class="hljs-number">+1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// 用于记录每个节点到生成树的最短距离</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(e<span class="hljs-number">+1</span>, INT_MAX)</span></span>;<br>    <br>    <span class="hljs-comment">// 从第一个节点开始</span><br>    minDist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> totalWeight = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录生成树的总权重</span><br><br>    <span class="hljs-comment">// Prim算法的主循环</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= e; i++) &#123;<br>        <span class="hljs-comment">// 第一步：选距离生成树最近的节点</span><br>        <span class="hljs-type">int</span> minDistance = INT_MAX;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= e; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!isTree[j] &amp;&amp; minDist[j] &lt; minDistance) &#123;<br>                minDistance = minDist[j];<br>                u = j;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 将选中的节点u加入生成树</span><br>        isTree[u] = <span class="hljs-literal">true</span>;<br>        totalWeight += minDistance;<br><br>        <span class="hljs-comment">// 更新非生成树节点到生成树的距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= e; k++) &#123;<br>            <span class="hljs-keyword">if</span> (!isTree[k] &amp;&amp; grid[u][k] &lt; minDist[k]) &#123;<br>                minDist[k] = grid[u][k];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 输出生成树的总权重</span><br>    cout &lt;&lt; totalWeight &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>Kruskal算法<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// l,r为 边两边的节点，val为边的数值</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> l, r, val;<br>&#125;;<br><br><span class="hljs-comment">// 节点数量</span><br><span class="hljs-type">int</span> n = <span class="hljs-number">10001</span>;<br><span class="hljs-comment">// 并查集标记节点关系的数组</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">father</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// 节点编号是从1开始的，n要大一些</span><br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 并查集的查找操作</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 路径压缩</span><br>&#125;<br><br><span class="hljs-comment">// 并查集的加入集合</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> v, e;<br>    <span class="hljs-type">int</span> v1, v2, val;<br>    vector&lt;Edge&gt; edges;<br>    <span class="hljs-type">int</span> result_val = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; v &gt;&gt; e;<br>    <span class="hljs-keyword">while</span> (e--) &#123;<br>        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;<br>        edges.<span class="hljs-built_in">push_back</span>(&#123;v1, v2, val&#125;);<br>    &#125;<br><br>    <span class="hljs-comment">// 执行Kruskal算法</span><br>    <span class="hljs-comment">// 按边的权值对边进行从小到大排序</span><br>    <span class="hljs-built_in">sort</span>(edges.<span class="hljs-built_in">begin</span>(), edges.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> Edge&amp; a, <span class="hljs-type">const</span> Edge&amp; b) &#123;<br>            <span class="hljs-keyword">return</span> a.val &lt; b.val;<br>    &#125;);<br><br>    <span class="hljs-comment">// 并查集初始化</span><br>    <span class="hljs-built_in">init</span>();<br><br>    <span class="hljs-comment">// 从头开始遍历边</span><br>    <span class="hljs-keyword">for</span> (Edge edge : edges) &#123;<br>        <span class="hljs-comment">// 并查集，搜出两个节点的祖先</span><br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(edge.l);<br>        <span class="hljs-type">int</span> y = <span class="hljs-built_in">find</span>(edge.r);<br><br>        <span class="hljs-comment">// 如果祖先不同，则不在同一个集合</span><br>        <span class="hljs-keyword">if</span> (x != y) &#123;<br>            result_val += edge.val; <span class="hljs-comment">// 这条边可以作为生成树的边</span><br>            <span class="hljs-built_in">join</span>(x, y); <span class="hljs-comment">// 两个节点加入到同一个集合</span><br>        &#125;<br>    &#125;<br>    cout &lt;&lt; result_val &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="拓扑排序">1.8 拓扑排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> m, n, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 记录每个文件的入度</span><br><br>    unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; umap;<span class="hljs-comment">// 记录文件依赖关系</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-comment">// 记录结果</span><br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-comment">// s-&gt;t，先有s才能有t</span><br>        cin &gt;&gt; s &gt;&gt; t;<br>        inDegree[t]++; <span class="hljs-comment">// t的入度加一</span><br>        umap[s].<span class="hljs-built_in">push_back</span>(t); <span class="hljs-comment">// 记录s指向哪些文件</span><br>    &#125;<br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 入度为0的文件，可以作为开头，先加入队列</span><br>        <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) que.<span class="hljs-built_in">push</span>(i);<br>        <span class="hljs-comment">//cout &lt;&lt; inDegree[i] &lt;&lt; endl;</span><br>    &#125;<br>    <span class="hljs-comment">// int count = 0;</span><br>    <span class="hljs-keyword">while</span> (que.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-type">int</span>  cur = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 当前选中的文件</span><br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//count++;</span><br>        result.<span class="hljs-built_in">push_back</span>(cur);<br>        vector&lt;<span class="hljs-type">int</span>&gt; files = umap[cur]; <span class="hljs-comment">//获取该文件指向的文件</span><br>        <span class="hljs-keyword">if</span> (files.<span class="hljs-built_in">size</span>() != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// cur有后续文件</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; files.<span class="hljs-built_in">size</span>(); i++) &#123;<br>                inDegree[files[i]] --; <span class="hljs-comment">// cur的指向的文件入度-1</span><br>                <span class="hljs-keyword">if</span>(inDegree[files[i]] == <span class="hljs-number">0</span>) que.<span class="hljs-built_in">push</span>(files[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == n) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) cout &lt;&lt; result[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        cout &lt;&lt; result[n - <span class="hljs-number">1</span>];<br>    &#125; <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="dijkstra算法">1.9 Dijkstra算法</h2><ul><li>参加科学大会<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 节点结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> x; <span class="hljs-comment">// 节点的索引</span><br>    <span class="hljs-type">double</span> g; <span class="hljs-comment">// g是起点到当前节点的成本</span><br>    shared_ptr&lt;Node&gt; parent; <span class="hljs-comment">// 父节点指针</span><br><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">double</span> g, shared_ptr&lt;Node&gt; parent = <span class="hljs-literal">nullptr</span>) <br>        : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">g</span>(g), <span class="hljs-built_in">parent</span>(parent) &#123;&#125;<br><br>    <span class="hljs-comment">// 获取g值</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getG</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> g;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 节点比较结构体，用于优先队列</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CompareNode</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> shared_ptr&lt;Node&gt;&amp; n1, <span class="hljs-type">const</span> shared_ptr&lt;Node&gt;&amp; n2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n1-&gt;<span class="hljs-built_in">getG</span>() &gt; n2-&gt;<span class="hljs-built_in">getG</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 检查节点是否合法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidNode</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> grid[x][v] != INT_MAX;<br>&#125;<br><br><span class="hljs-comment">// Dijkstra算法实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, vector&lt;shared_ptr&lt;Node&gt;&gt;&amp; path, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// openList优先队列，按g值排序</span><br>    priority_queue&lt;shared_ptr&lt;Node&gt;, vector&lt;shared_ptr&lt;Node&gt;&gt;, CompareNode&gt; openList_pq;<br>    <span class="hljs-comment">// closedList数组，记录已访问节点</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">closedList</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br><br>    <span class="hljs-comment">// 初始化起始节点</span><br>    shared_ptr&lt;Node&gt; startNode = <span class="hljs-built_in">make_shared</span>&lt;Node&gt;(start, <span class="hljs-number">0</span>);<br>    openList_pq.<span class="hljs-built_in">push</span>(startNode);<br><br>    <span class="hljs-comment">// Dijkstra算法主循环</span><br>    <span class="hljs-keyword">while</span> (!openList_pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// 获取openList中g值最小的节点</span><br>        shared_ptr&lt;Node&gt; current = openList_pq.<span class="hljs-built_in">top</span>();<br>        openList_pq.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-comment">// 如果当前节点是目标节点，构建路径并返回</span><br>        <span class="hljs-keyword">if</span> (current-&gt;x == end) &#123;<br>            <span class="hljs-keyword">while</span> (current) &#123;<br>                path.<span class="hljs-built_in">push_back</span>(current);<br>                current = current-&gt;parent;<br>            &#125;<br>            <span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 将当前节点标记为已访问</span><br>        closedList[current-&gt;x] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 获取当前节点的所有nextNode</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; v++) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isValidNode</span>(current-&gt;x, v, grid) || closedList[v]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">double</span> temp_g = current-&gt;g + grid[current-&gt;x][v];<br>            shared_ptr&lt;Node&gt; newNode = <span class="hljs-built_in">make_shared</span>&lt;Node&gt;(v, temp_g, current); <span class="hljs-comment">// 创建新节点</span><br>            openList_pq.<span class="hljs-built_in">push</span>(newNode); <span class="hljs-comment">// 将新节点加入openList_pq</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, INT_MAX));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        grid[p1][p2] = val;<br>    &#125;<br><br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> end = n;<br>    vector&lt;shared_ptr&lt;Node&gt;&gt; path;<br><br>    <span class="hljs-built_in">dijkstra</span>(grid, start, end, path, n);<br><br>    <span class="hljs-comment">// 打印路径</span><br>    <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">empty</span>()) &#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; path.<span class="hljs-built_in">back</span>()-&gt;g &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="a算法">1.10 A*算法</h2><ul><li><p>骑士的攻击</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> BOARD_SIZE = <span class="hljs-number">1000</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-type">double</span> g, h;<br>    shared_ptr&lt;Node&gt; parent;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">double</span> g, <span class="hljs-type">double</span> h, shared_ptr&lt;Node&gt; parent = <span class="hljs-literal">nullptr</span>)<br>        : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y), <span class="hljs-built_in">g</span>(g), <span class="hljs-built_in">h</span>(h), <span class="hljs-built_in">parent</span>(parent) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getF</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> g + h;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> shared_ptr&lt;Node&gt;&amp; n1, <span class="hljs-type">const</span> shared_ptr&lt;Node&gt;&amp; n2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n1-&gt;<span class="hljs-built_in">getF</span>() &gt; n2-&gt;<span class="hljs-built_in">getF</span>();<br>    &#125;<br>&#125;; <br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">heuristic</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(x1 - x2, <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(y1 - y2, <span class="hljs-number">2</span>);<br>&#125;<br><br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">nextNodeGenerator</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        &#123;x + <span class="hljs-number">2</span>, y - <span class="hljs-number">1</span>&#125;,<br>        &#123;x - <span class="hljs-number">2</span>, y + <span class="hljs-number">1</span>&#125;,<br>        &#123;x + <span class="hljs-number">1</span>, y - <span class="hljs-number">2</span>&#125;,<br>        &#123;x - <span class="hljs-number">1</span>, y + <span class="hljs-number">2</span>&#125;,<br>        &#123;x - <span class="hljs-number">2</span>, y - <span class="hljs-number">1</span>&#125;,<br>        &#123;x + <span class="hljs-number">2</span>, y + <span class="hljs-number">1</span>&#125;,<br>        &#123;x - <span class="hljs-number">1</span>, y - <span class="hljs-number">2</span>&#125;,<br>        &#123;x + <span class="hljs-number">1</span>, y + <span class="hljs-number">2</span>&#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidNode</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (x &gt;= <span class="hljs-number">1</span> &amp;&amp; x &lt;= BOARD_SIZE &amp;&amp; y &gt;= <span class="hljs-number">1</span> &amp;&amp; y &lt;= BOARD_SIZE);<br>&#125;<br><br><span class="hljs-function">string <span class="hljs-title">toString</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(x) + <span class="hljs-string">&quot;_&quot;</span> + <span class="hljs-built_in">to_string</span>(y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">aStar</span><span class="hljs-params">(shared_ptr&lt;Node&gt; startNode, shared_ptr&lt;Node&gt; endNode, <span class="hljs-type">int</span>&amp; result)</span> </span>&#123;<br>    priority_queue&lt;shared_ptr&lt;Node&gt;, vector&lt;shared_ptr&lt;Node&gt;&gt;, cmp&gt; openList_pq;<br>    unordered_map&lt;string, shared_ptr&lt;Node&gt;&gt; closeList;<br><br>    openList_pq.<span class="hljs-built_in">push</span>(startNode);<br><br>    <span class="hljs-keyword">while</span> (!openList_pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        shared_ptr&lt;Node&gt; current = openList_pq.<span class="hljs-built_in">top</span>();<br>        openList_pq.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">toString</span>(current-&gt;x, current-&gt;y) == <span class="hljs-built_in">toString</span>(endNode-&gt;x, endNode-&gt;y)) &#123; <br>            <span class="hljs-keyword">while</span> (current) &#123;<br>                result++;<br>                current = current-&gt;parent;<br>            &#125;<br>            result--;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        closeList.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">toString</span>(current-&gt;x, current-&gt;y), current); <br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; nextNodes = <span class="hljs-built_in">nextNodeGenerator</span>(current-&gt;x, current-&gt;y);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; nextNode : nextNodes) &#123;<br>            <span class="hljs-type">int</span> nextX = nextNode.first;<br>            <span class="hljs-type">int</span> nextY = nextNode.second;<br>            string nextKey = <span class="hljs-built_in">toString</span>(nextX, nextY); <br><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isValidNode</span>(nextX, nextY) || closeList.<span class="hljs-built_in">find</span>(nextKey) != closeList.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">double</span> nextG = current-&gt;g + <span class="hljs-built_in">heuristic</span>(current-&gt;x, current-&gt;y, nextX, nextY);<br>            <span class="hljs-type">double</span> nextH = <span class="hljs-built_in">heuristic</span>(nextX, nextY, endNode-&gt;x, endNode-&gt;y);<br>            shared_ptr&lt;Node&gt; newNode = <span class="hljs-built_in">make_shared</span>&lt;Node&gt;(nextX, nextY, nextG, nextH, current);<br>            openList_pq.<span class="hljs-built_in">push</span>(newNode);<br>        &#125;<br>    &#125;<br>    result = <span class="hljs-number">-1</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> startX, startY, endX, endY;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; startX &gt;&gt; startY &gt;&gt; endX &gt;&gt; endY;<br>        shared_ptr&lt;Node&gt; startNode = <span class="hljs-built_in">make_shared</span>&lt;Node&gt;(startX, startY, <span class="hljs-number">0</span>, <span class="hljs-built_in">heuristic</span>(startX, startY, endX, endY));<br>        shared_ptr&lt;Node&gt; endNode = <span class="hljs-built_in">make_shared</span>&lt;Node&gt;(endX, endY, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">aStar</span>(startNode, endNode, result);<br>        <span class="hljs-keyword">if</span> (result != <span class="hljs-number">-1</span>) &#123;<br>            cout &lt;&lt; result &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;No path found.&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p></p></li><li><p>A*基本实现</p></li></ul><p><strong><code>openlist_pq</code>（优先队列）</strong>：</p><p>作用：存储尚未被扩展的节点，并根据节点的 f 值（总代价，即 g + h）进行排序。</p><p>详细描述：优先队列的作用是确保每次从队列中取出的节点都是当前代价最小的节点，从而保证算法优先扩展最有可能通向最优解的路径。</p><p><strong><code>closelist</code>（关闭集合）</strong>：</p><p>作用：记录已经被扩展和处理过的节点，避免重复处理。</p><p>详细描述：<code>closelist</code> 是一个哈希表，用于存储所有已处理过的节点。通过检查 <code>closelist</code>，算法可以防止重复扩展同一个节点，避免死循环和无效计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 节点结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> x, y; <span class="hljs-comment">// 节点的坐标</span><br>    <span class="hljs-type">double</span> g, h; <span class="hljs-comment">// g是起点到当前节点的成本，h是启发函数的估算成本</span><br>    shared_ptr&lt;Node&gt; parent; <span class="hljs-comment">// 父节点指针</span><br><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">double</span> g, <span class="hljs-type">double</span> h, shared_ptr&lt;Node&gt; parent = <span class="hljs-literal">nullptr</span>) <br>        : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y), <span class="hljs-built_in">g</span>(g), <span class="hljs-built_in">h</span>(h), <span class="hljs-built_in">parent</span>(parent) &#123;&#125;<br><br>    <span class="hljs-comment">// 获取f值，f = g + h</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getF</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> g + h;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 节点比较结构体，用于优先队列</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CompareNode</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> shared_ptr&lt;Node&gt;&amp; n1, <span class="hljs-type">const</span> shared_ptr&lt;Node&gt;&amp; n2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n1-&gt;<span class="hljs-built_in">getF</span>() &gt; n2-&gt;<span class="hljs-built_in">getF</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 欧氏距离启发函数</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">heuristic</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">pow</span>(x1 - x2, <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(y1 - y2, <span class="hljs-number">2</span>));<br>&#125;<br><br><span class="hljs-comment">// 检查节点是否合法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidNode</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-type">int</span> rows = grid.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> cols = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">return</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols &amp;&amp; grid[x][y] == <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// 生成nextNode</span><br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">NextNodeGenerator</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        &#123;x - <span class="hljs-number">1</span>, y&#125;,<br>        &#123;x + <span class="hljs-number">1</span>, y&#125;,<br>        &#123;x, y - <span class="hljs-number">1</span>&#125;,<br>        &#123;x, y + <span class="hljs-number">1</span>&#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">// 坐标转换为字符串键</span><br><span class="hljs-function">string <span class="hljs-title">toString</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(x) + <span class="hljs-string">&quot;_&quot;</span> + <span class="hljs-built_in">to_string</span>(y);<br>&#125;<br><br><span class="hljs-comment">// A*算法实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">aStar</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> startX, <span class="hljs-type">int</span> startY, <span class="hljs-type">int</span> endX, <span class="hljs-type">int</span> endY, vector&lt;shared_ptr&lt;Node&gt;&gt;&amp; path)</span> </span>&#123;<br>    <span class="hljs-comment">// openList优先队列，按f值排序，确保每次扩展的都是当前总代价最小的节点</span><br>    priority_queue&lt;shared_ptr&lt;Node&gt;, vector&lt;shared_ptr&lt;Node&gt;&gt;, CompareNode&gt; openList_pq;<br>    <span class="hljs-comment">// closedList集合，记录已经处理过的节点，防止重复处理</span><br>    unordered_map&lt;string, shared_ptr&lt;Node&gt;&gt; closeList;<br><br>    <span class="hljs-comment">// 初始化起始节点</span><br>    shared_ptr&lt;Node&gt; startNode = <span class="hljs-built_in">make_shared</span>&lt;Node&gt;(startX, startY, <span class="hljs-number">0</span>, <span class="hljs-built_in">heuristic</span>(startX, startY, endX, endY));<br>    openList_pq.<span class="hljs-built_in">push</span>(startNode);<br><br>    <span class="hljs-comment">// A*算法主循环</span><br>    <span class="hljs-keyword">while</span> (!openList_pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// 获取openList中f值最小的节点</span><br>        shared_ptr&lt;Node&gt; current = openList_pq.<span class="hljs-built_in">top</span>();<br>        openList_pq.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-comment">// 如果当前节点是目标节点，构建路径并返回</span><br>        <span class="hljs-keyword">if</span> (current-&gt;x == endX &amp;&amp; current-&gt;y == endY) &#123;<br>            <span class="hljs-keyword">while</span> (current) &#123;<br>                path.<span class="hljs-built_in">push_back</span>(current);<br>                current = current-&gt;parent;<br>            &#125;<br>            <span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 将当前节点标记为已访问</span><br>        closeList.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">toString</span>(current-&gt;x, current-&gt;y), current);<br><br>        <span class="hljs-comment">// 获取当前节点的所有nextNode</span><br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; nextNodes = <span class="hljs-built_in">NextNodeGenerator</span>(current-&gt;x, current-&gt;y);<br><br>        <span class="hljs-comment">// 遍历所有nextNode</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; nextNode : nextNodes) &#123;<br>            <span class="hljs-type">int</span> nx = nextNode.first;<br>            <span class="hljs-type">int</span> ny = nextNode.second;<br><br>            <span class="hljs-comment">// 如果nextNode无效或已访问，跳过</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isValidNode</span>(grid, nx, ny) || closeList.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">toString</span>(nx, ny)) != closeList.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">double</span> temp_g = current-&gt;g + <span class="hljs-built_in">heuristic</span>(current-&gt;x, current-&gt;y, nx, ny);<br>            <span class="hljs-type">double</span> h = <span class="hljs-built_in">heuristic</span>(nx, ny, endX, endY); <span class="hljs-comment">// 计算h值</span><br>            shared_ptr&lt;Node&gt; newNode = <span class="hljs-built_in">make_shared</span>&lt;Node&gt;(nx, ny, temp_g, h, current); <span class="hljs-comment">// 创建新节点</span><br>            openList_pq.<span class="hljs-built_in">push</span>(newNode); <span class="hljs-comment">// 将新节点加入openList_pq</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 5x5 网格表示，0为可通行，1为障碍物</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; grid = &#123;<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;<br>    &#125;;<br><br>    <span class="hljs-type">int</span> startX = <span class="hljs-number">0</span>, startY = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> endX = <span class="hljs-number">4</span>, endY = <span class="hljs-number">4</span>;<br>    vector&lt;shared_ptr&lt;Node&gt;&gt; path;<br><br>    <span class="hljs-built_in">aStar</span>(grid, startX, startY, endX, endY, path);<br><br>    <span class="hljs-comment">// 打印路径</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; node : path) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; node-&gt;x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; node-&gt;y &lt;&lt; <span class="hljs-string">&quot;) &quot;</span> &lt;&lt; endl;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="category-chain-item">算法与数据结构</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>算法与数据结构</div><div>https://tanghw9827.github.io/2024/08/06/算法与数据结构/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Harvey Tang</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年8月6日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/2024/08/03/%E5%86%B3%E7%AD%96%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/" title="决策模块概述"><span class="hidden-mobile">决策模块概述</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.5.1/Valine.min.js",(function(){var n=Object.assign({appId:"8m9N9Kn5CK6K1op9xdv7Ij9V-MdYXbMMI",appKey:"FVHAVAwSHL9MNMaYrhu3uMfm",path:"window.location.pathname",placeholder:"欢迎留言哦！请保持文明用语😊",avatar:"mp",meta:["nick","mail","link"],requiredFields:["nick","mail"],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"https://8m9n9kn5.api.lncldglobal.com",emojiCDN:"https://cdn.jsdelivr.net/npm/@valine/emojis@latest",emojiMaps:{smile:"smile.png",grin:"grin.png",joy:"joy.png",rofl:"rofl.png",stuck_out_tongue:"stuck_out_tongue.png",stuck_out_tongue_winking_eye:"stuck_out_tongue_winking_eye.png"},enableQQ:!0},{el:"#valine",path:window.location.pathname});new Valine(n),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var n="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(n),Fluid.plugins.fancyBox(n)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script>window.MathJax?(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise()):window.MathJax={tex:{inlineMath:{"[+]":[["$","$"]]}},loader:{load:["ui/lazy"]},options:{renderActions:{insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{let e=t.parentNode;"li"===e.nodeName.toLowerCase()&&e.parentNode.classList.add("has-jax")})},"",!1]}}},Fluid.events.registerRefreshCallback((function(){"MathJax"in window&&MathJax.startup.document&&"function"==typeof MathJax.startup.document.state&&(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise())}))</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>